[1,["20g1ukYUVPvKWKBRznAKo+@f9941","baIUdvKGZPgZxNbjWTFuRI","a64otVPqBEOZLBFYuPbbbr@4f797","a64otVPqBEOZLBFYuPbbbr@b9a12","a64otVPqBEOZLBFYuPbbbr@30991","c89m0XNRpI2qEsAhLShXXE","81ivqNTzJLL43XsJozFf9Q@127b0","a64otVPqBEOZLBFYuPbbbr@a3475","54TknWPwVPqJqeCR+Y/Czo@f9941","95EkngnxZFbYuFpsqVTaFr@f9941","a64otVPqBEOZLBFYuPbbbr@543ef","a64otVPqBEOZLBFYuPbbbr@3f138","81ivqNTzJLL43XsJozFf9Q@64191","adRY0rBfVNSqtqk2zUbZdm@e6c45","4eXnkNOExIBqziEftRMdWk@bf627","71zV9oD41MkoQqGbWZq/Tj@95b6d","b8VJRZbiFOoKacwjITz6Cx@078fa","c6V8r7FwxFt7pRrGFGnbQ/@35302","5ewlGlizJGjpk66JWPKkbB","57fEr0LK9BD4qqSb7r1b8c","43pXMFxf1HzpGhfPB+RjpL","12Y9dMgWdJKJGmTiZyQR9H@2e76e","a64otVPqBEOZLBFYuPbbbr@02d94","a64otVPqBEOZLBFYuPbbbr@9e060","55rE4ioUVKRpLxpFr6G48I","d0MqyYBeFAkIi762QNy1/B@b47c0","6fAc9/gb9Kfr1dCvwZaWSA@b47c0","20g1ukYUVPvKWKBRznAKo+@6c48a","ffQb3aO8lNWIqrlRztydVT@6c48a","385ZDvnjJDQ56OS9bbdyVu","54TknWPwVPqJqeCR+Y/Czo@6c48a","81ivqNTzJLL43XsJozFf9Q@3df8b","a2+PkRanZMSbmuDfo35D7X@6c48a","81ivqNTzJLL43XsJozFf9Q@73ece","81ivqNTzJLL43XsJozFf9Q@30732","81ivqNTzJLL43XsJozFf9Q@54e73","81ivqNTzJLL43XsJozFf9Q@f1394","81ivqNTzJLL43XsJozFf9Q@d24b3","81ivqNTzJLL43XsJozFf9Q@75ee4","81ivqNTzJLL43XsJozFf9Q@bded7","81ivqNTzJLL43XsJozFf9Q@a72ab","95EkngnxZFbYuFpsqVTaFr@6c48a","a64otVPqBEOZLBFYuPbbbr@a35d3","a64otVPqBEOZLBFYuPbbbr@e2d07","f6SJZOjTJB/JrJeh5xTdF7","a64otVPqBEOZLBFYuPbbbr@c1b5d"],["node","_parent","_mesh","_spriteFrame","_material","mainTexture","_effectAsset","value","root","_target","targetInfo","_normalSprite","_skeleton","_hoverSprite","_pressedSprite","_disabledSprite","_textureSource","asset","data","_cameraComponent","btnExitFullScreen","btnEnterFullScreen","scene","idleAnimClip","moveAnimClip","jumpBeginAnimClip","jumpLoopAnimClip","jumpLandAnimClip","_envmapHDR","_envmapLDR"],[["cc.Node",["_name","_layer","_id","_objFlags","__editorExtras__","_parent","_components","_prefab","_lpos","_children","_lrot","_euler","_lscale"],-2,1,9,4,5,2,5,5,5],"cc.ImageAsset",["cc.Widget",["_alignFlags","_right","_top","_name","_originalWidth","_originalHeight","_left","_isAbsRight","_isAbsTop","node","__prefab"],-6,1,4],"cc.SpriteFrame",["cc.UITransform",["node","_contentSize","__prefab"],3,1,5,4],["cc.Sprite",["_type","_sizeMode","_enabled","node","_spriteFrame","__prefab","_color"],0,1,6,4,5],["cc.Button",["_transition","node","clickEvents","_normalColor","_target","_normalSprite","__prefab","_hoverSprite","_pressedSprite","_disabledSprite"],2,1,9,5,1,6,4,6,6,6],["cc.Material",["_states","_defines","_name","_techIdx","_props"],-1,12],"cc.TextureCube",["cc.Node",["_name","_lpos","_parent","_components","_children","_prefab","_lrot","_euler"],2,5,1,2,12,4,5,5],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler","_lscale"],2,1,9,4,5,5,5,5],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides","mountedComponents"],1,9,9],["cc.Camera",["_clearFlags","_visibility","_near","_projection","_priority","_orthoHeight","_far","node","_color"],-4,1,5],["cc.MeshRenderer",["_name","_shadowCastingMode","node","_materials","bakeSettings","_mesh"],1,1,3,4,6],["cc.ModelBakeSettings",["_castShadow","_receiveShadow"],1],["cc.EffectAsset",["_name","shaders","techniques","combinations"],-1],["cc.Prefab",["_name"],2],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","skin","lightProbeInfo"],3,4,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumHDR","_skyIllumLDR","_skyColorHDR","_groundAlbedoHDR","_skyColorLDR","_groundAlbedoLDR"],1,5,5,5,5],["cc.ShadowsInfo",["_enabled","_type","_distance","_shadowColor","_size"],0,5,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",["_fogStart","_fogEnd","_accurate","_fogColor"],0,5],["cc.OctreeInfo",[],3],["cc.SkinInfo",[],3],["cc.LightProbeInfo",[],3],["cc.Canvas",["node","_cameraComponent"],3,1,1],["c3adeHs1ohAOLMzNRNZmf98",["node","btnEnterFullScreen","btnExitFullScreen"],3,1,1,1],["cc.MountedComponentsInfo",["targetInfo","components"],3,4,9],["cc.TargetInfo",["localID"],2],["d197aTs7v1GkpwypdJ1ezJ8",["velocity","jumpVelocity","maxJumpTimes","node","idleAnimClip","moveAnimClip","jumpBeginAnimClip","jumpLoopAnimClip","jumpLandAnimClip"],0,1,6,6,6,6,6],["cc.CapsuleCollider",["_radius","_cylinderHeight","node","_center","_material"],1,1,5,6],["cc.RigidBody",["node","_angularFactor"],3,1,5],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,6],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["cc.ClickEvent",["_componentId","handler","target"],1,1],["195f1/tNVtIs5euOncQEpW0",["zoomSensitivity","len","node","target","lookAtOffset"],1,1,1,5],["cc.PlaneCollider",["node","_material"],3,1,6],["cc.BoxCollider",["node","_center","_size","_material"],3,1,5,5,6],["cc.Label",["_string","_actualFontSize","_fontSize","_overflow","_enableWrapText","node","_color"],-2,1,5],["cc.DirectionalLight",["_illuminanceHDR","_shadowEnabled","_shadowPcf","_shadowBias","_shadowSaturation","_shadowDistance","node","_staticSettings"],-3,1,4],["cc.StaticLightSettings",[],3],["bb644EreiZDYIqjgHIPb0bj",["node"],3,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.CompPrefabInfo",["fileId"],2],["0d3fdUMUH1Fq4G13IWj7Lf2",["node","__prefab"],3,1,4],["cc.Mask",["_type","node","__prefab"],2,1,4],["cc.Graphics",["node","__prefab","_fillColor"],3,1,4,5],["cc.PhysicsMaterial",["_friction"],2],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.SkeletalAnimation",["node","__prefab"],3,1,4],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","__prefab","_materials","bakeSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,3,4,1,6,6]],[[21,0,1,2,3,4,5,5],[52,0,2],[10,0,1,2,3,4,5,6,2],[0,0,5,7,8,10,11,2],[33,0,2],[0,0,5,9,7,8,10,11,2],[4,0,2,1,1],[14,1],[13,1,2,3,4,5,2],[46,0,1,2,3,1],[51,0,1,2,3],[0,0,1,5,6,7,3],[37,0,1,2,3],[38,0,1,2,2],[5,0,1,3,5,6,4,3],[43,0,1,2,3],[54,0,1,2,2],[55,0,1,2,1],[0,0,2,5,6,8,3],[4,0,1,1],[0,0,1,5,9,6,7,8,3],[0,0,9,7,8,10,11,2],[0,0,5,7,8,2],[42,0,1,2,2],[6,1,6,2,1],[0,0,2,5,6,8,10,11,3],[14,0,1,3],[57,0,1,2,3,4],[59,0,1,2,3,4,5,6,7,2],[0,0,1,5,9,6,8,3],[0,0,3,1,5,6,4],[0,0,1,9,6,7,3],[0,0,5,6,7,2],[2,0,1,2,9,4],[39,0,1,2,2],[41,0,1,2,3],[5,0,1,3,4,3],[6,0,1,2,3,4,5,7,8,9,2],[47,0,1,2,3,4,5,6,6],[7,0,1,4,3],[20,0,1,2,3,4,5,4],[0,3,4,5,7,3],[0,0,1,5,9,6,7,3],[2,3,0,4,5,9,10,5],[5,2,0,1,3,5,6,4,4],[15,0,3,1,2,5],[7,2,0,1,4,4],[17,0,2],[18,0,1,2,3,2],[19,0,1,2,3,4,5,6],[22,0,1,2,3,4,5,6,1],[23,0,1,2,3,4,5,3],[24,0,1,2,3,4,4],[25,0,1,2,2],[26,0,1,2,3,4],[27,1],[28,1],[29,1],[0,0,1,2,5,9,6,8,4],[0,0,2,5,6,12,3],[0,0,2,5,9,6,8,3],[0,0,2,5,6,10,11,3],[0,0,5,6,8,2],[0,0,2,5,6,3],[0,0,1,5,6,7,8,3],[0,0,9,6,7,2],[0,0,5,9,7,10,11,2],[0,0,9,7,10,11,2],[0,0,5,9,7,12,2],[0,0,5,9,7,8,10,12,11,2],[0,0,5,7,12,2],[0,0,5,6,7,8,10,11,2],[9,0,2,3,1,2],[9,0,4,5,1,6,7,2],[10,0,1,2,3,4,5,7,6,2],[4,0,2,1],[30,0,1,1],[2,0,6,1,9,4],[2,3,0,1,2,7,8,4,5,9,10,9],[31,0,1,2,1],[11,0,1,3,2,3],[11,0,1,2,3],[32,0,1,1],[34,0,1,2,3,4,5,6,7,8,4],[35,0,1,2,3,4,3],[36,0,1,1],[40,0,1,2,2],[6,1,6,3,4,5,1],[12,2,0,1,7,4],[12,3,4,5,6,0,1,7,8,7],[44,0,1,2,3,4,3],[13,0,2,3,4,5,2],[45,0,1,1],[48,0,1,2,3,4,5,6,7,7],[49,1],[50,0,1],[15,0,1,2,4],[7,2,3,0,1,4,5],[16,0,2],[16,1],[53,0,1,1],[56,0,2],[58,0,1,1]],[[[[47,"rooster_jump"],[48,"rooster_jump",[-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19],[49,null,null,"f46876e4-e81b-4931-b493-6d367be385e7",null,null,[-1,-2]],[50,[51,30000,0.5208,[2,0.365754,0.568107,0.908079,0.7812496875],[2,0.455624,0.403274,0.370948,0],[2,0.365754,0.568107,0.908079,0.5208],[2,0.455624,0.403274,0.370948,0]],[52,true,1,0.01,[4,4283190348],[0,2048,2048]],[53,true,61,62],[54,15,30,true,[4,4292861919]],[55],[56],[57]]],[58,"Canvas",33554432,"a11llmW1NKKbL5e/NWqPpr",1,[-27,-28,-29,-30,-31],[[19,-20,[5,1280,720]],[76,-22,-21],[77,45,5.684341886080802e-14,5.684341886080802e-14,-23],[79,-26,-25,-24]],[1,640,360,0]],[41,0,{},1,[40,"e2e+8lu1tW2p0rFH7l0luL",null,null,-38,[80,"51Qu1yhspB4bYMGLfoWasb",null,[[82,[4,["e2e+8lu1tW2p0rFH7l0luL"]],[[83,2,4,2,-35,1,2,3,4,5],[84,0.23,0.25,-36,[1,0,0.35,0],6],[85,-37,[1,0,1,0]]]]],[[12,"rooster_man_skin",["_name"],[4,["e2e+8lu1tW2p0rFH7l0luL"]]],[13,["_lpos"],[4,["e2e+8lu1tW2p0rFH7l0luL"]],[1,-2.021,1.794,5.832]],[13,["_lscale"],[4,["e2e+8lu1tW2p0rFH7l0luL"]],[1,1,1,1]],[13,["_lrot"],[4,["e2e+8lu1tW2p0rFH7l0luL"]],[3,0,0,0,1]],[13,["_euler"],[4,["e2e+8lu1tW2p0rFH7l0luL"]],[1,0,0,0]],[12,1,["_shadowCastingMode"],[4,["25x+iOlM9UjbIlUqmbrKDP"]]],[34,["_skinningRoot"],[4,["25x+iOlM9UjbIlUqmbrKDP"]],-32],[12,1,["_shadowCastingMode"],[4,["32hFEfVZNdLIwbllHXTrT2"]]],[34,["_skinningRoot"],[4,["32hFEfVZNdLIwbllHXTrT2"]],-33],[86,["_materials","0"],[4,["d83plz7mdZP7Kb5g/e7i4H"]],7],[34,["_skinningRoot"],[4,["d83plz7mdZP7Kb5g/e7i4H"]],-34],[12,true,["_active"],[4,["a0MDSmHWBVf6n6/3JluzFm"]]],[12,false,["_useBakedAnimation"],[4,["785KrFqJxasqzQSuEUWIi/"]]]]],0]],[29,"BtnEnterFullScreen",33554432,2,[-44],[[19,-39,[5,200,40]],[36,1,0,-40,46],[37,2,-42,[[15,"c3adeHs1ohAOLMzNRNZmf98","onEnterFullScreen",2]],[4,4292269782],-41,47,48,49,50],[33,33,14,10,-43]],[1,526,330,0]],[29,"BtnExitFullScreen",33554432,2,[-50],[[19,-45,[5,200,40]],[36,1,0,-46,51],[37,2,-48,[[15,"c3adeHs1ohAOLMzNRNZmf98","onExitFullScreen",2]],[4,4292269782],-47,52,53,54,55],[33,33,14,10,-49]],[1,526,330,0]],[29,"BtnToggleStats",33554432,2,[-56],[[19,-51,[5,100,40]],[36,1,0,-52,56],[37,2,-54,[[15,"c3adeHs1ohAOLMzNRNZmf98","onToggleStats",2]],[4,4292269782],-53,57,58,59,60],[33,33,228,10,-55]],[1,362,330,0]],[4,["4eEaTnahNPd5NO5OdceSOx"]],[25,"Main Camera","c9DMICJLFO5IeO07EPon7U",1,[[88,0.1,14,1822425087,-57],[90,0.01,2,-58,3,[1,0,0.5,0]]],[1,-10,7.036,10],[3,-0.1205904774487396,0.37940952255126037,0.049950211252314816,0.9159756150367534],[1,-15,45,0]],[59,"Plane","87Y5As9Q1PZ7D0rZka9Mlp",1,[[91,"Plane<ModelComponent>",-59,[8],[7],9],[92,-60,10]],[1,50,1,50]],[18,"map0_a-001","3aDxBTHUlOXbWe7qOsupS2",1,[[8,1,-61,[11],[7],12],[9,-62,[1,-0.000947117805480957,0.5143269580724237,-0.008321523666381836],[1,1.0862784385681152,1.0286535656208997,1.0737289190292358],13]],[1,-11.094,-0.443,3.038]],[18,"map0_a-002","26jFADMmhI3rSkomE6qRgH",1,[[8,1,-63,[14],[7],15],[9,-64,[1,-0.000947117805480957,0.5143269580724237,-0.008321523666381836],[1,1.0862784385681152,1.0286535656208997,1.0737289190292358],16]],[1,-1.904,0,5.849]],[18,"map0_a-003","feojjV/adAMpXAKABgmSDK",1,[[8,1,-65,[17],[7],18],[9,-66,[1,-0.000947117805480957,0.5143269580724237,-0.008321523666381836],[1,1.0862784385681152,1.0286535656208997,1.0737289190292358],19]],[1,-12.225,0,3.471]],[60,"map0_flag_stick","dbv+wkveRApJ8dTjnk32dr",1,[-68],[[8,1,-67,[22],[7],23]],[1,-6.714,1.767,0]],[18,"map0_bridge_wooden_2","d8cpYtWW1PmIDGOg366zTa",1,[[8,1,-69,[24],[7],25],[9,-70,[1,8.940696716308594e-8,0.01,-1.1920928955078125e-7],[1,1.1748130917549133,1.975217044353485,1.0000004768371582],26]],[1,-6.785,0,1.426]],[25,"map0_bridge_wooden_3","3fVc+9mkpIC59m4IUC3WG2",1,[[8,1,-71,[27],[7],28],[9,-72,[1,8.940696716308594e-8,0.01,-1.1920928955078125e-7],[1,1.1748130917549133,1.975217044353485,1.0000004768371582],29]],[1,-6.785,0,2.445],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[18,"map0_bridge_wooden_5","f3jBcHchxMkaKRfuJynePV",1,[[8,1,-73,[30],[7],31],[9,-74,[1,8.940696716308594e-8,0.01,-1.1920928955078125e-7],[1,1.1748130917549133,1.975217044353485,1.0000004768371582],32]],[1,-6.785,0,3.436]],[25,"map0_bridge_wooden_4","94mc8JY5RL346hA+Hgpf3e",1,[[8,1,-75,[33],[7],34],[9,-76,[1,8.940696716308594e-8,0.01,-1.1920928955078125e-7],[1,1.1748130917549133,1.975217044353485,1.0000004768371582],35]],[1,-6.785,0,4.41],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[25,"map0_bridge_wooden_6","7da1bWrfdAFZN9KY7nEtZT",1,[[8,1,-77,[36],[7],37],[9,-78,[1,8.940696716308594e-8,0.01,-1.1920928955078125e-7],[1,1.1748130917549133,1.975217044353485,1.0000004768371582],38]],[1,-6.785,-0.487,5.399],[3,0,1,0,6.123233995736766e-17],[1,0,180,0]],[18,"map0_st_3","a2we59btlN1Je2wZBMMvBN",1,[[8,1,-79,[39],[7],40],[9,-80,[1,0,1.4908403408167459,-2.086162567138672e-7],[1,1.224271297454834,2.981681535315971,1.2734647393226624],41]],[1,-6.767,-0.009,0]],[18,"map0_st_4","82wS1CCjdPLZFfdJeHWVTr",1,[[8,1,-81,[42],[7],43],[9,-82,[1,0,1.4908403408167459,-2.086162567138672e-7],[1,1.224271297454834,2.981681535315971,1.2734647393226624],44]],[1,-8.223,-1.525,0.821]],[41,0,{},2,[40,"4eEaTnahNPd5NO5OdceSOx",null,null,-87,[81,"bfhGGZXfJM2qzbV8JFDR7g",null,[[35,"ui_joystick_panel",["_name"],7],[23,["_lpos"],7,[1,0,0,0]],[23,["_lscale"],7,[1,1,1,1]],[23,["_lrot"],7,[3,0,0,0,1]],[23,["_euler"],7,[1,0,0,0]],[13,["_lpos"],[4,["a4DfMArKhELaPwA+TvA+0Z"]],[1,-459.524,-168.153,0]],[13,["_contentSize"],[4,["0f76PkyR9CI6GSE13j2hvT"]],[5,1280,720]],[13,["_contentSize"],[4,["0fZyqsL71Jo5X5Qe6tNsnC"]],[5,1280,720]],[13,["_contentSize"],[4,["c3kE+xlWdKP42qlgQXWPi7"]],[5,640,360]],[13,["_lpos"],[4,["55mHcC2xxEDI4zcUpi9jjH"]],[1,-320,-180,0]],[35,false,["_enabled"],-83],[35,false,["_enabled"],-84],[23,["_color"],-85,[4,973023999]],[23,["_color"],-86,[4,2168258346]],[12,true,["_active"],[4,["c8n4U+w/NMw43H85mvryWv"]]],[12,true,["_active"],[4,["98/3PSxQREu4vt8e5EQGPC"]]],[12,true,["_active"],[4,["3cVpy0IIlLDYkv7r48ymH2"]]],[12,true,["_active"],[4,["efAUyEQUFMnI3ErfBo/lvM"]]]]],45]],[30,"Label",512,33554432,4,[[19,-88,[5,200,40]],[38,"Enter FullScreen",20,20,1,false,-89,[4,4278190080]]]],[30,"Label",512,33554432,5,[[19,-90,[5,200,40]],[38,"Exit FullScreen",20,20,1,false,-91,[4,4278190080]]]],[30,"Label",512,33554432,6,[[19,-92,[5,100,40]],[38,"Stats",20,20,1,false,-93,[4,4278190080]]]],[61,"Main Light","c0y6F5f+pAvI805TdmxIjx",1,[[93,85000,true,2,0.05,0.66,25,-94,[94]]],[3,-0.8005972817813567,-0.1453229557254247,-0.33176781330654553,0.4773419623260901],[1,-120.254,-42.248,-4.821]],[62,"map0_flag",13,[[8,1,-95,[20],[7],21]],[1,0,-0.004,0]],[72,"Camera",2,[-96],[1,0,0,1000]],[89,0,1073741824,451.6666666666667,2000,6,41943040,27,[4,4278190080]],[4,["d0AoChjSREeLgHKkf59Vzb"]],[4,["b9MreVDjBOKJh1aR0UFV4C"]],[63,"Entry","bcE6BeQW1J/7eAcJt8KCEr",1,[[95,-97]]]],0,[0,-1,3,0,-2,21,0,-1,25,0,-2,8,0,-3,9,0,-4,3,0,-5,10,0,-6,11,0,-7,12,0,-8,13,0,-9,14,0,-10,15,0,-11,16,0,-12,17,0,-13,18,0,-14,19,0,-15,20,0,-16,2,0,-17,31,0,0,2,0,19,28,0,0,2,0,0,2,0,20,5,0,21,4,0,0,2,0,-1,27,0,-2,21,0,-3,4,0,-4,5,0,-5,6,0,7,3,0,7,3,0,7,3,0,0,3,0,0,3,0,0,3,0,8,3,0,0,4,0,0,4,0,9,4,0,0,4,0,0,4,0,-1,22,0,0,5,0,0,5,0,9,5,0,0,5,0,0,5,0,-1,23,0,0,6,0,0,6,0,9,6,0,0,6,0,0,6,0,-1,24,0,0,8,0,0,8,0,0,9,0,0,9,0,0,10,0,0,10,0,0,11,0,0,11,0,0,12,0,0,12,0,0,13,0,-1,26,0,0,14,0,0,14,0,0,15,0,0,15,0,0,16,0,0,16,0,0,17,0,0,17,0,0,18,0,0,18,0,0,19,0,0,19,0,0,20,0,0,20,0,10,29,0,10,30,0,10,29,0,10,30,0,8,21,0,0,22,0,0,22,0,0,23,0,0,23,0,0,24,0,0,24,0,0,25,0,0,26,0,-1,28,0,0,31,0,22,1,97],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[17,23,24,25,26,27,4,7,-1,2,4,-1,2,4,-1,2,4,-1,2,4,-1,2,-1,2,-1,2,4,-1,2,4,-1,2,4,-1,2,4,-1,2,4,-1,2,4,-1,2,4,17,3,11,13,14,15,3,11,13,14,15,3,11,13,14,15,28,29],[12,13,14,15,16,17,18,19,20,21,1,2,7,1,2,7,1,2,7,1,10,22,10,23,3,4,1,3,4,1,3,4,1,3,4,1,3,4,1,2,11,1,2,11,1,24,0,0,0,8,9,0,0,0,8,9,0,0,0,8,9,25,26]],[[[10,".bin",2489017538,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":1200,"count":600,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[{"name":"default_btn_normal","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[3],0,[0],[16],[27]],[[[45,"../shaders/standard-ground",[{},{}],[{"hash":1369295976,"name":"../shaders/standard-ground|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1},{"name":"fadeRange","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"albedoOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"emissiveOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"normalOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1},{"name":"fadeRange","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n  vec4 fadeRange;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n  vec4 fadeRange;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  vec3 viewDir = FSInput_worldPos.xyz - cc_cameraPos.xyz;\n  float distant = sqrt(dot(viewDir,viewDir));\n  float factor = 1.0 - ((distant - fadeRange.x) / (fadeRange.y - fadeRange.x));\n  factor = clamp(factor,0.0,1.0);\n  baseColor.a = factor;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, DEFAULT_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, DEFAULT_UV).r;\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 albedoOut;\n    layout(location = 1) out vec4 emissiveOut;\n    layout(location = 2) out vec4 normalOut;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      albedoOut = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      normalOut = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      emissiveOut = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        albedoOut = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  uniform highp vec4 cc_reflectionProbeBlendData1;\n  uniform highp vec4 cc_reflectionProbeBlendData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 pbrParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleParam;\n    uniform vec4 anisotropyParam;\n    uniform vec4 fadeRange;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  vec3 viewDir = FSInput_worldPos.xyz - cc_cameraPos.xyz;\n  float distant = sqrt(dot(viewDir,viewDir));\n  float factor = 1.0 - ((distant - fadeRange.x) / (fadeRange.y - fadeRange.x));\n  factor = clamp(factor,0.0,1.0);\n  baseColor.a = factor;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normal.xyz, FSInput_worldTangent, FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture2D(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture2D(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, DEFAULT_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, DEFAULT_UV).r;\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":98,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":128}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"FIX_ANISOTROPIC_ROTATION_MAP","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":966767561,"name":"../shaders/standard-ground|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1},{"name":"fadeRange","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["CC_SURFACES_USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1},{"name":"fadeRange","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n  vec4 fadeRange;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n  vec4 fadeRange;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV && !CC_USE_LIGHTMAP\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture2D(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":98,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":128}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"../shaders/standard-ground|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"anisotropyIntensity":{"type":13,"value":[1],"handleInfo":["anisotropyParam",0,13]},"anisotropyRotation":{"type":13,"value":[0],"handleInfo":["anisotropyParam",1,13]},"anisotropyMapResolutionHeight":{"type":13,"value":[0],"handleInfo":["anisotropyParam",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"anisotropyMap":{"value":"black","type":28},"anisotropyMapNearestFilter":{"value":"black","type":28},"fadeBegin":{"type":13,"value":[0],"handleInfo":["fadeRange",0,13]},"fadeEnd":{"type":13,"value":[100],"handleInfo":["fadeRange",1,13]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"anisotropyParam":{"type":16,"value":[1,0,0,0]},"albedoMap":{"type":28,"value":"grey"},"fadeRange":{"type":16,"value":[0,100,0,0]}}},{"phase":"forward-add","propertyIndex":0,"program":"../shaders/standard-ground|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"../shaders/standard-ground|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]},{"name":"transparent","passes":[{"program":"../shaders/standard-ground|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.8],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0.6],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"anisotropyIntensity":{"type":13,"value":[1],"handleInfo":["anisotropyParam",0,13]},"anisotropyRotation":{"type":13,"value":[0],"handleInfo":["anisotropyParam",1,13]},"anisotropyMapResolutionHeight":{"type":13,"value":[0],"handleInfo":["anisotropyParam",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"anisotropyMap":{"value":"black","type":28},"anisotropyMapNearestFilter":{"value":"black","type":28},"fadeBegin":{"type":13,"value":[0],"handleInfo":["fadeRange",0,13]},"fadeEnd":{"type":13,"value":[100],"handleInfo":["fadeRange",1,13]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[1,0.8,0.6,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"anisotropyParam":{"type":16,"value":[1,0,0,0]},"albedoMap":{"type":28,"value":"grey"},"fadeRange":{"type":16,"value":[0,100,0,0]}}},{"phase":"forward-add","propertyIndex":0,"program":"../shaders/standard-ground|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"../shaders/standard-ground|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}}]}]]],0,0,[],[],[]],[[[97,"Mat-Ground","1",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":1,"metallic":0.426,"fadeBegin":70},"tilingOffset",8,[2,50,50,0,0],"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,6],[28,29]],[[{"name":"default_btn_pressed","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[3],0,[0],[16],[30]],[[[98,"ui_joystick_panel"],[31,"ui_joystick_panel",33554432,[-5,-6,-7,-8],[[6,-2,[1,"0f76PkyR9CI6GSE13j2hvT"],[5,1280,720]],[43,"HUD<Widget>",45,100,100,-3,[1,"61G89wei9G5ZMYyMlGMFfu"]],[100,-4,[1,"easj9qwJ5K1ZLYsbWsVi7m"]]],[0,"4eEaTnahNPd5NO5OdceSOx",null,null,null,-1,0]],[20,"buttons",33554432,1,[-10,-11,-12,-13,-14],[[75,-9,[1,"9aY0foPx9Ml5YHJPUweARm"]]],[0,"30T2Nxx6BCL5T3LtY8Iets",null,null,null,1,0],[1,526,-262,0]],[64,"checker_movement",33554432,1,[[6,-15,[1,"c3kE+xlWdKP42qlgQXWPi7"],[5,640,360]],[44,false,1,0,-16,[1,"b9MreVDjBOKJh1aR0UFV4C"],[4,2166366353],1],[78,"Button<Widget>",45,0.5,0.5,false,false,640,320,-17,[1,"5fpMWtX9VDEIN1lSKC3+iO"]],[87,-19,[1,"47ImTsej1IxZzl08BeNJ5N"],[4,4292269782],-18,2]],[0,"55mHcC2xxEDI4zcUpi9jjH",null,null,null,1,0],[1,-320,-180,0]],[31,"bg",33554432,[-23,-24],[[6,-20,[1,"cfTiBJ1LRKnqIgyLxpKExR"],[5,200,200]],[16,1,-21,[1,"28qJfL/xRO9Z5lmtrZW9/j"]],[17,-22,[1,"4cHz4mgF1BGbLN0QWBG3NI"],[4,16777215]]],[0,"93JDZm285OVoyAXp6qXmwW",null,null,null,1,0]],[42,"btn_slot_0",33554432,2,[-29],[[6,-25,[1,"2dHICoBZVFY4KL6BwgHAvi"],[5,145,145]],[16,1,-26,[1,"ca9ZVXsJxMDa1C1Njx7HT0"]],[17,-27,[1,"c5BzPzgh9FTbIickzeHfr/"],[4,16777215]],[24,-28,[1,"bcV5VHVx5KcLLbzdAvy9Ee"],[[15,"0d3fdUMUH1Fq4G13IWj7Lf2","onButtonSlot",1]]]],[0,"ccEKdclRtN441KT5DHcVNl",null,null,null,1,0]],[20,"btn_slot_1",33554432,2,[-34],[[6,-30,[1,"9fmUoMBctKi63OqPdrnnRq"],[5,75,75]],[16,1,-31,[1,"a2QeFppMBBFKRrc8TMYIGz"]],[17,-32,[1,"c3RVl6G6VJt5b3KtGyDbY8"],[4,16777215]],[24,-33,[1,"fby9NaiydCR6KX9V/vbpVm"],[[15,"0d3fdUMUH1Fq4G13IWj7Lf2","onButtonSlot",1]]]],[0,"c8n4U+w/NMw43H85mvryWv",null,null,null,1,0],[1,20,162,0]],[20,"btn_slot_2",33554432,2,[-39],[[6,-35,[1,"95ZkIYBsBFgLsUygJt+7Oh"],[5,75,75]],[16,1,-36,[1,"bcwQBb41dHp4HsbQa2IIQ1"]],[17,-37,[1,"50NhAT9FdFCrcVMxFj3SIL"],[4,16777215]],[24,-38,[1,"bdnOQ+Yk9GTLboQd2DgLJv"],[[15,"0d3fdUMUH1Fq4G13IWj7Lf2","onButtonSlot",1]]]],[0,"98/3PSxQREu4vt8e5EQGPC",null,null,null,1,0],[1,-80.68,133.072,0]],[20,"btn_slot_3",33554432,2,[-44],[[6,-40,[1,"48eZ3Vm7dKAo0aPHRcrxKO"],[5,75,75]],[16,1,-41,[1,"772K/kx1tHoq0kMZ1BCIVA"]],[17,-42,[1,"3fooQ4VwhBDodiM4ri6Fne"],[4,16777215]],[24,-43,[1,"4d+OJjWFNIIZESl24KgXyQ"],[[15,"0d3fdUMUH1Fq4G13IWj7Lf2","onButtonSlot",1]]]],[0,"3cVpy0IIlLDYkv7r48ymH2",null,null,null,1,0],[1,-142,52,0]],[20,"btn_slot_4",33554432,2,[-49],[[6,-45,[1,"085x7WealEvI1F0fR4p4va"],[5,75,75]],[16,1,-46,[1,"dbkZp8qcFPyIzu05/1dZNS"]],[17,-47,[1,"df6qBz7SREoqTkniEKY+nh"],[4,16777215]],[24,-48,[1,"694a0S7zBDvZQlgOPhm5Jn"],[[15,"0d3fdUMUH1Fq4G13IWj7Lf2","onButtonSlot",1]]]],[0,"efAUyEQUFMnI3ErfBo/lvM",null,null,null,1,0],[1,-154,-46,0]],[42,"bg",33554432,4,[-53],[[6,-50,[1,"216/LDx2tPzphG3fjCxye+"],[5,185,185]],[16,1,-51,[1,"1aKo5aGehJboNl4hOWEBMo"]],[17,-52,[1,"14rk9pHEtDz5in/yBpDyLl"],[4,16777215]]],[0,"78UVt6ZrtLhZax+chb7E/p",null,null,null,1,0]],[31,"pointer",33554432,[-57],[[6,-54,[1,"adequmQjREpoUJ0dk84JA0"],[5,80,80]],[16,1,-55,[1,"44tESj1WZMP7z80rcz6r7C"]],[17,-56,[1,"0bOzHhVY5PFJCCaKNllzV3"],[4,16777215]]],[0,"b7w1ruaU5L7b+1uFnOQIQx",null,null,null,1,0]],[11,"checker_camera",33554432,1,[[6,-58,[1,"0fZyqsL71Jo5X5Qe6tNsnC"],[5,1280,720]],[44,false,1,0,-59,[1,"d0AoChjSREeLgHKkf59Vzb"],[4,973078527],0],[43,"Button<Widget>",45,640,320,-60,[1,"25m5M04TNAl4BNHIjAMrrL"]]],[0,"0cMqkAXtpP1Jpj0Hz+MYxg",null,null,null,1,0]],[20,"ctrl",33554432,1,[4,11],[[6,-61,[1,"f6kGxWOihLP63f3kZc7xbA"],[5,200,200]]],[0,"a4DfMArKhELaPwA+TvA+0Z",null,null,null,1,0],[1,-437.524,-168.153,0]],[11,"btn_gen",33554432,4,[[6,-62,[1,"330hXv5fNDIoJcPkluEZRC"],[5,200,200]],[14,1,0,-63,[1,"d5DBbkpuJDHqUEboCZJBpq"],[4,3036676095],3]],[0,"155mXp7QxLQ6rSQqjKBV9N",null,null,null,1,0]],[11,"btn_gen",33554432,10,[[6,-64,[1,"b4b+vIgdhE5INrZcdqsLWg"],[5,200,200]],[14,1,0,-65,[1,"4dvg+TolRBTIJkmXXsk7e6"],[4,3036676095],4]],[0,"23M5L4yeRI8Y6hzkpL+FCe",null,null,null,1,0]],[11,"btn_gen",33554432,11,[[6,-66,[1,"9a9lIrJfFHVKHDZT62NZ6m"],[5,200,200]],[14,1,0,-67,[1,"dcI06aayBASJNr/hRJ89aG"],[4,4279966634],5]],[0,"9b13ak09dAe7xrTgLNVUL2",null,null,null,1,0]],[11,"btn_gen",33554432,5,[[6,-68,[1,"2atdsdGPNM0aT5MY1V1ktA"],[5,150,150]],[14,1,0,-69,[1,"fcNqjl+SRIQ7MHHxRtNJOf"],[4,3036676095],6]],[0,"bau+2rH21Aj7r8DqrX4r1z",null,null,null,1,0]],[11,"btn_gen",33554432,6,[[6,-70,[1,"88m1h1wVdOGZxYW6F9gUEC"],[5,80,80]],[14,1,0,-71,[1,"a9qSA6I1FCj4Rf4HSmK31b"],[4,3036676095],7]],[0,"66xil0plpLdrmEVEjs++Q7",null,null,null,1,0]],[11,"btn_gen",33554432,7,[[6,-72,[1,"d4deUhUkVHUboSSiFy0F3X"],[5,80,80]],[14,1,0,-73,[1,"08/qgDefdHRKrJ0E0sWvF/"],[4,3036676095],8]],[0,"b4b1kl8RlD06C4VNz6Iygb",null,null,null,1,0]],[11,"btn_gen",33554432,8,[[6,-74,[1,"8fxaiTLEFG2JVkZk+9LKCx"],[5,80,80]],[14,1,0,-75,[1,"47HcrQAdJHd4IgGp80xNqy"],[4,3036676095],9]],[0,"97yW+4f/NM1JNUW/Tonl/O",null,null,null,1,0]],[11,"btn_gen",33554432,9,[[6,-76,[1,"ff6S/rKI5FDZvdxzJm/F7g"],[5,80,80]],[14,1,0,-77,[1,"891wYbHoRAs4dvZxBmafGl"],[4,3036676095],10]],[0,"722yKBoOFNJZVp2+6pOlu4",null,null,null,1,0]]],0,[0,8,1,0,0,1,0,0,1,0,0,1,0,-1,12,0,-2,3,0,-3,13,0,-4,2,0,0,2,0,-1,5,0,-2,6,0,-3,7,0,-4,8,0,-5,9,0,0,3,0,0,3,0,0,3,0,9,3,0,0,3,0,0,4,0,0,4,0,0,4,0,-1,14,0,-2,10,0,0,5,0,0,5,0,0,5,0,0,5,0,-1,17,0,0,6,0,0,6,0,0,6,0,0,6,0,-1,18,0,0,7,0,0,7,0,0,7,0,0,7,0,-1,19,0,0,8,0,0,8,0,0,8,0,0,8,0,-1,20,0,0,9,0,0,9,0,0,9,0,0,9,0,-1,21,0,0,10,0,0,10,0,0,10,0,-1,15,0,0,11,0,0,11,0,0,11,0,-1,16,0,0,12,0,0,12,0,0,12,0,0,13,0,0,14,0,0,14,0,0,15,0,0,15,0,0,16,0,0,16,0,0,17,0,0,17,0,0,18,0,0,18,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,21,0,18,1,4,1,13,11,1,13,77],[0,0,0,0,0,0,0,0,0,0,0],[3,3,11,3,3,3,3,3,3,3,3],[0,0,0,0,0,0,0,0,0,0,0]],[[[46,"glasses",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":1},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,6],[31,5]],[[[101,0]],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":false,"mipmaps":[{"front":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@e9a6d","back":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@40c10","left":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@8fd34","right":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@74afd","top":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@bb97f","bottom":"6fAc9/gb9Kfr1dCvwZaWSA@b47c0@7d38f"}]}],[8],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[39,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_ALBEDO_MAP":true},{},{}],[[[{"roughness":1,"metallic":0},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,6],[32,5]],[[[27,"Skin-0",3281689399,["bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_glass_3","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_glass_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_glass_3/bone_glass_4","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_glass_1/bone_glass_2"],[[[7,0.4681698977947235,-0.08204750716686249,-0.8798210620880127,0,-0.8031873106956482,-0.4546065926551819,-0.3849973976612091,0,-0.36838430166244507,0.8869055509567261,-0.2787325978279114,0,0.374397873878479,0.37394407391548157,0.17662039399147034,1],[7,-0.46817004680633545,-0.08204798400402069,0.8798210620880127,0,-0.8031874299049377,0.4546065926551819,-0.3849973678588867,0,-0.36838415265083313,-0.8869054317474365,-0.2787330746650696,0,0.37439972162246704,-0.3739438056945801,0.17661702632904053,1],[7,-1.3988815794618858e-7,-0.000001231492547049129,1,0,0.9971639513969421,0.07525777071714401,2.3217087630200695e-7,0,-0.07525776326656342,0.9971640110015869,0.0000012174725725344615,0,-0.44831836223602295,-0.051258910447359085,-1.6472750985485618e-7,1],[7,0.349596232175827,0.32202067971229553,-0.8798211216926575,0,-0.12686483561992645,-0.9141567945480347,-0.38499730825424194,0,-0.9282715320587158,0.246211975812912,-0.2787325978279114,0,-0.0888296365737915,0.4993796944618225,0.17662036418914795,1],[7,-0.3495962917804718,0.3220207691192627,0.8798211216926575,0,-0.12686499953269958,0.9141567945480347,-0.3849974274635315,0,-0.9282716512680054,-0.2462121695280075,-0.2787325382232666,0,-0.08882833272218704,-0.4993809759616852,0.17661714553833008,1]],8,8,8,8,8]]],0,0,[],[],[]],[[[10,".bin",2973806768,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":246384,"length":28644,"count":14322,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":246384,"count":3422,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]]},"minPosition",8,[1,-0.2438947707414627,-0.0038653009105473757,-0.3882240355014801],"maxPosition",8,[1,0.2438947707414627,0.8053528666496277,0.2504148483276367]]],-1],0,0,[],[],[]],[[[99],[65,"rooster_man_skin",[-3,-4,-5,-6,-7],[[102,-2,[1,"785KrFqJxasqzQSuEUWIi/"]]],[0,"e2e+8lu1tW2p0rFH7l0luL",null,null,null,-1,0]],[21,"bone_umbrella_02",[-8,-9,-10,-11,-12,-13,-14,-15],[0,"benGb0PlldNbtGecPFd6E9",null,null,null,1,0],[1,0.31662672758102417,-0.002459030132740736,5.0821975699298317e-23],[3,2.3520286068330795e-13,-1.3222733112155363e-14,0.004201638023826175,0.9999911730800011],[1,2.6959342834381887e-11,-1.6285013765104459e-12,0.48147366825787236]],[21,"bone_hand_r",[-16,-17,-18,-19,-20],[0,"584vMH96FYE5rNkQ0V3mWR",null,null,null,1,0],[1,0.052205782383680344,9.53674295089968e-9,0],[3,0.652054305483034,-0.08249375168929023,0.06881243689519549,0.7505230257372578],[1,81.94165953142091,-12.331515498518879,-0.24580968838850137]],[21,"bone_hand_l",[-21,-22,-23,-24],[0,"b1hFz3ZhBUm5fil3yK5SNI",null,null,null,1,0],[1,0.052205782383680344,4.76837147544984e-9,-1.907348590179936e-8],[3,-0.6520543042807246,0.08249377388892332,0.06881243676831367,0.750523024353384],[1,-81.94165934691962,12.33151742164075,-0.245811357617708]],[73,"bone_head",[[[3,"bone_headtop",-25,[0,"5d3IFOx8hSYp6mlY6e710r",null,null,null,1,0],[1,0.42636215686798096,0.01933484524488449,2.288818166107376e-7],[3,0.9990196141429475,0.044269747648350254,1.993082019911684e-7,-8.878701501433315e-7],[1,-179.99989694229654,-0.000027428266402914755,5.0745978637686076]],-26,-27,-28],4,1,1,1],[0,"73A0jEPERSD66qFhUxQtvj",null,null,null,1,0],[1,0.02263561263680458,0,-5.0821975699298317e-23],[3,-1.4476211421193763e-14,6.309676301376597e-8,-0.022749747952640884,0.9997411909929926],[1,1.646575656554567e-7,0.000007235975096898593,-2.6071540075396427]],[66,"bone_ head_zhuandong",5,[-29,-30,-31,-32],[0,"ec0Bn8Op9RNorUzRj1c21s",null,null,null,1,0],[3,8.742088148723514e-8,5.787045423976264e-10,0.006619769304734759,0.9999780890871282],[1,0.000010017914613494816,-1.6279626698722286e-12,0.7585752253897577]],[21,"bone_foot_l",[-33,-34,-35,-36],[0,"65Y9Ac+UlZpYrXfRPzU6Ph",null,null,null,1,0],[1,0.049356188625097275,-2.38418573772492e-9,-8.881783998477905e-18],[3,-0.0009132542142502386,0.014958505454432938,0.02706361364115386,0.9995213704058519],[1,-0.1512127847912036,1.7189026015418452,3.0997237491794527]],[21,"bone_foot_r",[-37,-38,-39,-40],[0,"14NhkLb+db9a1WEQyc4dM8",null,null,null,1,0],[1,0.049356188625097275,2.38418573772492e-9,0],[3,0.000913251828934071,-0.014958417929732374,0.027063613676653414,0.9995213717169319],[1,0.15121223954942156,-1.718892552420868,3.099723770591041]],[21,"bone_spine",[-41,-42,-43],[0,"1eDi6fAJJe25Xb61Kps2e8",null,null,null,1,0],[1,0.0809493139386177,0.035872071981430054,-2.9496604270207172e-8],[3,-0.000002144228363123901,-7.659694518958264e-7,0.11081653172288743,0.9938408807710246],[1,-0.00024037407456969643,-0.00006151509117988365,12.724774346273517]],[5,"bone_spine1",9,[-44,-45,-46],[0,"beMKqbfj1W8I6PMxOKXhfI",null,null,null,1,0],[1,0.08194933086633682,-0.00008420467202086002,-2.335582283130577e-10],[3,4.036575137591759e-14,2.0320881264270442e-7,-0.07326535110658738,0.9973124827892145],[1,0.0000017245770620127953,0.000023475457087495408,-8.403119998720873]],[5,"bone_neck",10,[-47,-48,5],[0,"954wY3ze9bQ5sAdYrfC60b",null,null,null,1,0],[1,0.12482303380966187,-0.005282969679683447,-4.964476746360802e-11],[3,3.8915731881374674e-14,1.642292451965781e-7,-0.059211576896847605,0.9982454553672466],[1,0.0000011221928475775634,0.000018918926153192943,-6.789117977144112]],[67,"bone_pelvis",[9,-49],[0,"647VygG21S26Gzm/ndhPKY",null,null,null,1,0],[3,-0.49999999254917427,-0.49999999254917427,-0.49999930709576956,0.5000007078049009],[1,-89.99991974527727,-89.99991974527727,-0.0000017074910602964197]],[5,"bone_clavicle_l",11,[-50,-51],[0,"c6iKV+iKNdpLgRJqDtwyU/",null,null,null,1,0],[1,-0.05992775037884712,0.027953913435339928,0.10586938261985779],[3,0.58150862361037,0.055661852171491416,0.8109875141980115,-0.032384111760895354],[1,-172.64856723078498,-108.76104212872221,0.6995686829883327]],[5,"bone_upperarm_l",13,[-52,-53],[0,"63QckikBNSZJljU14wThS1",null,null,null,1,0],[1,0.029605654999613762,-9.53674295089968e-9,-3.814697180359872e-8],[3,-0.02660698087396302,0.3285568078586897,-0.033399254287919615,0.9435184059632814],[1,-1.6247414049016333,38.33328736187656,-4.617848479394004]],[5,"bone_clavicle_r",11,[-54,-55],[0,"25avOkgS1fgKZgrFSXhCm/",null,null,null,1,0],[1,-0.05992775037884712,0.027954503893852234,-0.10586924850940704],[3,-0.5815087052429239,-0.05566409690479199,0.8109873661047854,-0.03238249621161062],[1,172.6484656049857,108.76104454981476,0.6998694924143966]],[5,"bone_upperarm_r",15,[-56,-57],[0,"96XBU06yhSE4rPpdTm4Uzt",null,null,null,1,0],[1,0.029605654999613762,-2.38418573772492e-9,-7.105427198782324e-17],[3,0.026606977405217988,-0.32855678122432164,-0.03339926206053697,0.9435184150607148],[1,1.6247408664558511,-38.333284146047845,-4.617849144938208]],[5,"bone_beak",6,[-58,-59],[0,"a0sqUcj8pb6bFjwQajLlDD",null,null,null,1,0],[1,0.03580043837428093,0.09719709306955338,-1.0587911840678754e-22],[3,0.6692984040946024,0.7429937054081852,3.7524079844248286e-7,-3.037563629693633e-7],[1,-0.000530799020168418,-179.99947500113467,84.02587673151524]],[32,"rooster_man_glass",1,[[28,1,-60,[1,"d83plz7mdZP7Kb5g/e7i4H"],[0],[26,true,true],1,1,2]],[0,"a0MDSmHWBVf6n6/3JluzFm",null,null,null,1,0]],[32,"rooster_man",1,[[28,1,-61,[1,"25x+iOlM9UjbIlUqmbrKDP"],[3],[26,true,true],1,4,5]],[0,"5ceaShyqdUv7l/7DK7bn1X",null,null,null,1,0]],[5,"bone_root",1,[12],[0,"5aCJP87bhUP4lJsCTjhi0X",null,null,null,1,0],[1,0,0.14251941442489624,-0.03963029757142067],[3,-0.5000003576277408,-0.49999964237200345,-0.49999964237200345,0.5000003576277408],[1,-90,-89.99991803772996,0]],[5,"bone_forearm_l",14,[4],[0,"76GGSAmc5dpo65JNSg9nL7",null,null,null,1,0],[1,0.06711332499980927,-8.881783998477905e-18,1.907348590179936e-8],[3,2.6519249732109414e-18,-1.0197920233036451e-16,-0.07613427362469753,0.997097574151918],[1,-5.93576801014433e-16,-1.1765295218820277e-14,-8.732795509707929]],[2,"bone_finger_0_l",4,[[3,"bone_finger_01_l",-62,[0,"a5OI85H2tcaa3kNirGbQd4",null,null,null,1,0],[1,0.03084503673017025,-1.907348590179936e-8,0],[3,-4.853984741989033e-9,-4.6412970979289494e-9,0.17410811682552554,0.9847265425769071],[1,-4.845043617552715e-7,-4.5443817038310296e-7,20.053520412820998]]],[0,"5eAuUcLuZXz5nfOxy/0FCZ",null,null,null,1,0],[1,0.022379731759428978,0.004396934527903795,-0.04376063868403435],[3,0.5445033385780378,0.4693929318746183,-0.16703552234487792,0.674748489482188],[1,68.49924697467203,58.30151789259091,16.604169441076028]],[2,"bone_finger_1_l",4,[[3,"bone_finger_11_l",-63,[0,"28BKkur31QJaPV7Noqxhg3",null,null,null,1,0],[1,0.0314410962164402,-3.552713599391162e-17,-1.776356799695581e-17],[3,6.588942409661047e-9,8.222415798215941e-9,0.1096205062272458,0.9939735130346694],[1,6.631377852222745e-7,8.74797903728569e-7,12.586879771984439]]],[0,"20X6NxpHFS9KgXoSenTl7R",null,null,null,1,0],[1,0.0556735023856163,-0.00004770278974319808,-0.03327147662639618],[3,-0.0012646270097878625,0.00003471650874858748,0.027434979385095842,0.999622789565859],[1,-0.1451887742393318,0.007964463525597336,3.144204014490132]],[2,"bone_finger_2_l",4,[[3,"bone_finger_21_l",-64,[0,"a8gnKi6cZV4aOhF44V31Kc",null,null,null,1,0],[1,0.036042939871549606,1.907348590179936e-8,-9.53674295089968e-9],[3,6.188158602603702e-9,8.124466659400267e-9,0.10204548673152129,0.9947797337288928],[1,6.23388158867684e-7,8.719330754870808e-7,11.713941817186289]]],[0,"fb15UiGb1Uupzdl9mk9dVH",null,null,null,1,0],[1,0.052794646471738815,-0.0013613509945571423,0.00014511108747683465],[3,-0.01627521786949302,-0.011405385178444524,0.03364321612800528,0.9992362926159138],[1,-1.8240886948382675,-1.2461672053695407,3.8765122313020344]],[2,"bone_finger_3_l",4,[[3,"bone_finger_31_l",-65,[0,"65ic6wznpQerRcOCVwIGQz",null,null,null,1,0],[1,0.03449873998761177,3.552713599391162e-17,-7.1525572131747595e-9],[3,-1.2238411242535222e-8,-1.5803397568841754e-9,0.12806618286029084,0.9917656239291592],[1,-0.000001414062546582506,-3.8979611713144865e-15,14.715717352984445]]],[0,"dcnzsbrL5U5om3YminTYix",null,null,null,1,0],[1,0.05076740309596062,0.000025672912670415826,0.0322396382689476],[3,-0.03273135467066726,-0.022148214574322256,0.017861720411422918,0.9990590943265253],[1,-3.7070163497335233,-2.471086118026938,2.128438172313537]],[2,"bone_root_foretwist_l",14,[[3,"bone_root_foretwist_1_l ",-66,[0,"ca6GYI9dlfvZ6q4Xkfig87",null,null,null,1,0],[1,0.026102885603904724,0,-3.552713599391162e-17],[3,0.022755179325720635,-8.47696695985497e-11,-3.72432592134372e-9,0.9997410673838774],[1,2.6077765582087054,-1.805805593140685e-15,-4.2688684861792634e-7]]],[0,"d9BwG7F1FUB5uDsumFzdNd",null,null,null,1,0],[1,0.06711332499980927,-8.881783998477905e-18,1.907348590179936e-8],[3,0.02268914108309818,-0.0017324643950004004,-0.07611455684478385,0.9968393931222589],[1,2.6077772284654923,-0.0000017201813868012736,-8.732795189841578]],[2,"bone_root_uparmtwist_l",13,[[3,"bone_root_uparmtwist_1_l",-67,[0,"62juD7oIpdU7wG1v3HGTmz",null,null,null,1,0],[1,0.03355666995048523,-4.76837147544984e-9,0],[3,-0.015106402892312472,2.9053302158497217e-17,4.389409512666199e-19,0.9998858917854853],[1,-1.7311321046728807,3.329643128792564e-15,-2.665394742998526e-24]]],[0,"be4d9eNm1S0KTu1AiDzvqd",null,null,null,1,0],[1,0.029605654999613762,-9.53674295089968e-9,-3.814697180359872e-8],[3,0.0019082441664501843,0.3273978744571319,-0.043309497456376,0.9438915604216563],[1,1.8375221873121028,38.333286380756235,-4.617848270425883]],[5,"bone_forearm_r",16,[3],[0,"53JipNmHNRzrUNrVNOT7KF",null,null,null,1,0],[1,0.06711332499980927,-4.76837147544984e-9,-1.907348590179936e-8],[3,1.5117700460293212e-17,-2.986057890665257e-17,-0.07613426621730351,0.997097574717516],[1,1.4840229058180398e-15,-3.318416752031913e-15,-8.732794658412276]],[2,"bone_finger_0_r",3,[[3,"bone_finger_01_r",-68,[0,"d0RJbgf4ZSUJJtL3Flj+WK",null,null,null,1,0],[1,0.030845031142234802,-1.907348590179936e-8,1.907348590179936e-8],[3,7.602167185688137e-10,-1.4997869527333713e-8,0.17410811682552554,0.9847265425769071],[1,4.0985986910712875e-7,-0.0000018177525473179555,20.053520412820994]]],[0,"6axqYBeupamKtOftZIb+Es",null,null,null,1,0],[1,0.022379731759428978,0.0043969727121293545,0.04376063495874405],[3,-0.5445033221002487,-0.46939291766982427,-0.16703545768539624,0.674748528667557],[1,-68.49924158866433,-58.3015125065832,16.60417202568024]],[2,"bone_finger_1_r",3,[[3,"bone_finger_11_r",-69,[0,"c5UQI9dnRc1LjTubUuoqFC",null,null,null,1,0],[1,0.031441107392311096,-7.105427198782324e-17,4.76837147544984e-9],[3,7.40567977612081e-9,8.167363618775911e-10,0.1096204988661961,0.9939735138464838],[1,8.537736462515938e-7,0,12.586878923356023]]],[0,"393MotQK1XiI52vYdr8ket",null,null,null,1,0],[1,0.05567348375916481,-0.000047721863666083664,0.03327146917581558],[3,0.0012646419108610252,-0.000034716101292522165,0.027434981245822457,0.9996227894959533],[1,0.14519048245531654,-0.007964463970100281,3.144204227734269]],[2,"bone_finger_2_r",3,[[3,"bone_finger_21_r",-70,[0,"d5W03StMJXR4UURAUVhLC+",null,null,null,1,0],[1,0.036042939871549606,0,-2.38418573772492e-9],[3,-8.433795015154029e-10,3.6583250810359363e-9,0.10204547935852548,0.9947797344852221],[1,-1.418732037832086e-7,4.3596655471981574e-7,11.71394096786954]]],[0,"52uSOlLN5f/Jru+JIt4GUG",null,null,null,1,0],[1,0.05279462784528732,-0.0013613509945571423,-0.00014512061898130924],[3,0.016275202964638275,0.011405382381888476,0.033643231021531675,0.99923629238915],[1,1.8240869778921995,1.246166916287235,3.8765139149532435]],[2,"bone_finger_3_r",3,[[3,"bone_finger_31_r",-71,[0,"24DWtsbCZfw5S5kFkld3B6",null,null,null,1,0],[1,0.03449873998761177,0,-2.38418573772492e-9],[3,5.341522365742899e-9,-6.822693115726523e-9,0.12806618286029084,0.9917656239291592],[1,7.311617514888952e-7,-8.827288568305363e-7,14.71571735298444]]],[0,"d3C0ukfgZQzZYCQYz55gAy",null,null,null,1,0],[1,0.050767410546541214,0.000025672912670415826,-0.0322396419942379],[3,0.032731347218006586,0.022148216435559972,0.017861735311449245,0.9990590942630379],[1,3.707015456246447,2.4710862933131836,2.128439867229841]],[68,"Point002",3,[-72],[0,"e6utPe40VeS48CQslW39z/",null,null,null,1,0],[1,0.2975570857524872,0.2975570261478424,0.2975570559501648]],[69,"bone_umbrella_01",33,[2],[0,"4f7uhIGiBYMaVSL9qhcUoN",null,null,null,1,0],[1,0.9598994255065918,-1.565982460975647,-0.7909132242202759],[3,0.07054208127531639,-0.13309977775984938,0.972116338515604,-0.17971668904317453],[1,3.360696792602539,3.3607025146484375,3.3607003688812256],[1,165.45984823803082,-174.48780063881833,-21.603991846723485]],[5,"bone_umbrella_03",2,[-73],[0,"1fDOcW5BtccZNk9dA8xsig",null,null,null,1,0],[1,0.24615947902202606,0.007094192318618298,3.814698956716711e-8],[3,0.11983949738443171,-0.16144530538977017,0.7958865793227201,0.5710853360822973],[1,126.88830946808727,-130.3749963146282,60.49855314174822]],[2,"bone_umbrella_04",35,[[3,"bone_umbrella_05",-74,[0,"c1miL0fcBdJKvVyEM9T6u/",null,null,null,1,0],[1,0.18627624213695526,-2.288818308215923e-7,-1.907348590179936e-8],[3,-0.002223119090179622,0.0012971909893602323,0.19577861886482595,0.9806447406846321],[1,-0.3020791986683441,0.21188758367865165,22.57998387519164]]],[0,"8cu5r7ZpRfwrZDE6KMeCmM",null,null,null,1,0],[1,0.18996208906173706,1.5258788721439487e-7,1.907348590179936e-8],[3,0.0008827445130349362,0.005781171009993893,0.0868297159475655,0.9962060024173429],[1,0.043911097403491375,0.661161523417227,9.962918244705952]],[5,"bone_umbrella_07",2,[-75],[0,"24k1xJbu9ZIITfCCQWqZwx",null,null,null,1,0],[1,0.24615947902202606,0.007094192318618298,3.814698956716711e-8],[3,0.5710853791799125,0.7958865563178884,-0.16144543483369575,0.11983927040309934],[1,53.111703958991775,130.3750126873638,60.49856298391358]],[2,"bone_umbrella_08",37,[[3,"bone_umbrella_09",-76,[0,"e8FjYtfsFcr6ZkjMNg67lL",null,null,null,1,0],[1,0.18627631664276123,0,-1.5258788721439487e-7],[3,0.002222927290902356,0.0012970728588350981,-0.19577850433824495,0.9806447641400724],[1,0.30205294443237457,0.21186849828939347,-22.57997057035076]]],[0,"8f7FILMK5aApYYf6EyzzYg",null,null,null,1,0],[1,0.18996208906173706,-7.629394360719743e-8,9.536743306171047e-8],[3,-0.000882674481042556,0.005781217056917897,-0.08682981945149904,0.9962059931907263],[1,-0.043902446217734696,0.6611675755633479,-9.962930105707276]],[5,"bone_umbrella_11",2,[-77],[0,"46yxHD3A1Z0KGd5AocWUde",null,null,null,1,0],[1,0.24615947902202606,0.007094192318618298,3.814698956716711e-8],[3,-0.5710853385047304,0.7958865826987166,0.16144544018504167,0.11983928182592853],[1,-53.11169705420396,130.3750191200956,-60.49855837819727]],[2,"bone_umbrella_12",39,[[3,"bone_umbrella_13",-78,[0,"38dNGEpNxU9bqQuYCLgkKI",null,null,null,1,0],[1,0.18627624213695526,-3.814697180359872e-8,-9.536743306171047e-8],[3,-0.0022229040209930276,0.0012970485357086882,0.19577847569453333,0.9806447699434971],[1,-0.3020495110709131,0.21186496058661536,22.579967235792974]]],[0,"35gZiF5gdU1oWRuj+oX/tK",null,null,null,1,0],[1,0.18996208906173706,3.814697180359872e-8,3.814697180359872e-8],[3,0.0008826762260458035,0.005781233347029303,0.08682983423199901,0.9962059918063687],[1,0.04390247404921161,0.6611694471599749,9.962931807697434]],[5,"bone_umbrella_15",2,[-79],[0,"08TyC2yrRfcJ6eDYU6Tgab",null,null,null,1,0],[1,0.24615947902202606,-0.008049850352108479,3.814697180359872e-8],[3,-0.11983924696188132,-0.16144526458932956,-0.7958866581684373,0.5710852902840066],[1,-126.88834515575448,-130.3750494741517,-60.49856568339173]],[2,"bone_umbrella_16",41,[[3,"bone_umbrella_17",-80,[0,"0d7Ot1Sp5fP7oPWIKw55et",null,null,null,1,0],[1,0.18627624213695526,1.1444091541079615e-7,5.7220457705398076e-8],[3,0.002223017641265626,0.0012973096546458765,-0.19577877362243673,0.9806447098613857],[1,0.30206979116747673,0.21189962626941308,-22.580001944307092]]],[0,"30PoEhSk1bprix+j3s1Tc1",null,null,null,1,0],[1,0.1899619996547699,-3.814697180359872e-8,-1.907348590179936e-8],[3,-0.0008826826893595731,0.005781012638401356,-0.08682981955348602,0.9962059943608318],[1,-0.04390546275228226,0.6611437987934551,-9.962930113876803]],[5,"bone_umbrella_19",2,[-81],[0,"37yRYV9QlR/6juEY4g4AGI",null,null,null,1,0],[1,0.24615947902202606,-0.0028823090251535177,0.0055097960866987705],[3,-0.48728645346028665,0.6739905545472993,-0.45270616278923276,-0.32147437662707784],[1,82.88868917163097,-110.00619004803372,-21.45596686118272]],[2,"bone_umbrella_20",43,[[3,"bone_umbrella_21",-82,[0,"a0eEHZydtY7oq7PFaj+gVj",null,null,null,1,0],[1,0.18627621233463287,-1.1444091541079615e-7,0],[3,-0.002222955275827292,0.0012971568206855495,0.19577870203836314,0.9806447244961848],[1,-0.3020584618452818,0.21187948034475368,22.579993640111486]]],[0,"59apaFknRafocnqLmdzTUk",null,null,null,1,0],[1,0.18996204435825348,1.1444091541079615e-7,0],[3,0.0008826792581372286,0.005781090889341146,0.08682977514803376,0.9962059977801772],[1,0.043904304073418166,0.6611529002201147,9.96292500734985]],[5,"bone_umbrella_23",2,[-83],[0,"11HW4NF1VUcK3HQ6gL3WvF",null,null,null,1,0],[1,0.24615947902202606,0.0009223175002261996,0.005509796552360058],[3,0.4881329142571167,0.674400793185322,0.45187374062213204,-0.3204995330823822],[1,-82.88873527241616,-110.00618348583016,21.638165227682656]],[2,"bone_umbrella_24",45,[[3,"bone_umbrella_25",-84,[0,"1cIWjxb7pTnpyaQGoc43LY",null,null,null,1,0],[1,0.18627618253231049,7.629394360719743e-8,7.629394360719743e-8],[3,0.002222785057851752,0.001297211757763788,-0.19577874508850832,0.9806447162147007],[1,0.30203909609802126,0.21188204886598594,-22.579998690466866]]],[0,"68qO9ryQRanJvS3vhOyu6E",null,null,null,1,0],[1,0.18996208906173706,0,-1.4210854397564648e-16],[3,-0.0008824483635944156,0.005781046285767638,-0.08682958293356347,0.9962060149970541],[1,-0.04387812096957655,0.6611500490212487,-9.962902742848515]],[5,"bone_umbrella_27",2,[-85],[0,"9dNlTd+yRQf6FRHDDUuMYV",null,null,null,1,0],[1,0.24615947902202606,0.0009223175002261996,-0.0073743052780628204],[3,-0.32049972191481113,0.4518736951426045,0.6744008738710568,0.4881327208994007],[1,-97.11129229847154,110.00618949093791,21.63814528516733]],[2,"bone_umbrella_28",47,[[3,"bone_umbrella_29",-86,[0,"b3CceDy6BW/q+BsdaWcDOd",null,null,null,1,0],[1,0.1862761527299881,-1.5258788721439487e-7,7.629394360719743e-8],[3,-0.002222892767115367,0.0012971327748828047,0.19577864763812305,0.980644735530303],[1,-0.3020502503984538,0.21187501211771378,22.57998730424258]]],[0,"6cnZ/0NxpWeoZb2sc77Rw7",null,null,null,1,0],[1,0.18996208906173706,7.629394360719743e-8,-7.629394360719743e-8],[3,0.0008826840422847163,0.0057810374111165914,0.08682963468079982,0.9962060103294557],[1,0.043905492424349685,0.6611466432162743,9.962908851046764]],[5,"bone_umbrella_31",2,[-87],[0,"699ujQXdxT55R0xlpwQSMo",null,null,null,1,0],[1,0.24615947902202606,-0.0018798065138980746,-0.007374305743724108],[3,-0.3204997152747373,-0.4518735367691302,0.6744010983174794,-0.48813256177471637],[1,97.11132972138466,110.00621142755006,-21.638152189389615]],[2,"bone_umbrella_32",49,[[3,"bone_umbrella_33",-88,[0,"6eyjFnQZhUt5rwdNLWWAlE",null,null,null,1,0],[1,0.18627618253231049,3.814697180359872e-8,7.629394360719743e-8],[3,0.002222838589552905,0.0012970829911262748,-0.19577878808793156,0.9806447076791573],[1,0.302042498091676,0.21186769642782508,-22.580003743133148]]],[0,"7eQiqr2JBf0biaQt7wEmIE",null,null,null,1,0],[1,0.18996210396289825,-3.814697180359872e-8,-1.4210854397564648e-16],[3,-0.0008826894580205744,0.005781121246021376,-0.0868295976662703,0.9962060130643525],[1,-0.0439052978141715,0.6611563030287984,-9.96290460077179]],[2,"bone_root_for_twist_r",16,[[3,"bone_root_for_twist_1_r",-89,[0,"0dECrjwStTI7xUZb/4/6wV",null,null,null,1,0],[1,0.026102906093001366,4.76837147544984e-9,-1.907348590179936e-8],[3,-0.022755197942527183,4.8559673747663065e-17,1.105271174902866e-18,0.9997410669601386],[1,-2.6077786920901236,5.565969934049762e-15,-5.127899560127437e-25]]],[0,"0f0LaiQbFS+4ayrO9xERvA",null,null,null,1,0],[1,0.06711332499980927,-4.76837147544984e-9,-1.907348590179936e-8],[3,-0.022689161574454334,0.0017324659085721133,-0.07611454940178401,0.9968393932215396],[1,-2.607779581521809,0.0000017338785739225099,-8.732794338633656]],[2,"bone_root_uparmtwist_r",15,[[3,"bone_root_uparmtwist_1_r",-90,[0,"e3M+FwnjNQgJi2BKRemZoW",null,null,null,1,0],[1,0.03355665132403374,2.38418573772492e-9,3.552713599391162e-17],[3,0.015106403823422493,1.4941668862548274e-8,2.568546200506751e-9,0.9998858917714178],[1,1.731132211382402,0.0000017075474306078671,3.2016514805910894e-7]]],[0,"006D+PlWxXzaOGnOoya7D8",null,null,null,1,0],[1,0.029605654999613762,-2.38418573772492e-9,-7.105427198782324e-17],[3,-0.0019082538465820702,-0.3273978476847976,-0.04330950903306557,0.943891569157143],[1,-1.8375235452332095,-38.33328322109269,-4.617849211677147]],[5,"bone_hair_1_1",6,[-91],[0,"cfEz5F9kNZB5zedkjdRjAL",null,null,null,1,0],[1,0.2118351012468338,-0.07980737090110779,-2.4193013814510778e-8],[3,0.9256975423749836,-0.37826453711699376,-1.427346028557749e-7,-7.494340182258496e-7],[1,-179.9998799650573,0.00006671849052828667,-44.45245089905327]],[2,"bone_hair_1_2",53,[[3,"bone_hair_1_3",-92,[0,"31Kzg/d49R9ID9TuXvEQuT",null,null,null,1,0],[1,0.06383813917636871,7.629394360719743e-8,-1.1039046121652518e-8],[3,9.593566615242615e-8,5.024091608048329e-8,0.4279849433533016,0.9037858641641059],[1,0.000011791391511878259,7.863000523411666e-7,50.67949479897935]]],[0,"acm5GtK0JSdJ9XbkqaLaIp",null,null,null,1,0],[1,0.07713363319635391,3.814697180359872e-8,-5.071278952328839e-9],[3,-8.977673722037355e-9,-6.116184185757654e-8,0.5969174508594194,0.8023026591377403],[1,0.000011685583532207388,-0.000017429780876272317,73.29888773406074]],[2,"bone_hair_2_1",6,[[3,"bone_hair_2_2",-93,[0,"1bYm+horlXy4bqKILxwOfu",null,null,null,1,0],[1,0.06964260339736938,-1.1444091541079615e-7,4.351095483912104e-9],[3,5.8923198497261784e-8,1.580124646173498e-8,0.2590152311491687,0.9658732370413516],[1,0.000006990670291441426,-6.365415529998197e-13,30.023274951617974]]],[0,"5bXRkC1G9QQbs+/g+q3jPX",null,null,null,1,0],[1,0.24348556995391846,-0.005518660414963961,1.1540576139168479e-7],[3,0.9717729353448555,-0.23591812590559533,-1.3354808818888843e-7,-6.45781330266999e-7],[1,-179.99991501758032,0.00003637925644032025,-27.29149864653299]],[2,"bone_hair_3_1",6,[[3,"bone_hair_3_2",-94,[0,"725HXVzB9c9p1J+seCHFrT",null,null,null,1,0],[1,0.04479064792394638,-9.34600848268019e-7,4.2724423998663497e-10],[3,7.978937938542896e-7,-1.1286558584620948e-7,0.15915867760165855,0.9872530148565979],[1,0.00009725195536903851,-0.00002877877871797719,18.31613249240328]]],[0,"b7MkCFXstWCbjArFrtysmC",null,null,null,1,0],[1,0.23033149540424347,0.058412861078977585,1.8052159589387884e-7],[3,0.9999971298080553,-0.002395908093463533,-4.4282497262718964e-8,2.3831317500704117e-7],[1,179.99997270324454,0.000005009014258383873,-0.27455110638609875]],[2,"bone_beard_1_1",17,[[3,"bone_beard_1_2",-95,[0,"70YJaLEKFS0o4zBCMfjjWI",null,null,null,1,0],[1,0.05913812667131424,3.814697180359872e-8,1.776356799695581e-17],[3,4.7567304261974336e-8,2.6396932362386966e-7,-0.17734375409719577,0.9841489688470142],[1,0.000011448980174415343,0.00003279895877112211,-20.43015812654131]]],[0,"5a0OUEmblZap+/b1obD49i",null,null,null,1,0],[1,0.024493694305419922,-0.019416121765971184,-1.1126012111617456e-7],[3,0.8620342384473383,-0.4802409581595895,-0.14157890899375267,-0.07887335658266278],[1,-152.6719974751102,32.677357632630354,-53.67159533082517]],[2,"bone_beard_2_1",17,[[3,"bone_beard_2_2",-96,[0,"4adurE01ZWc7PXFi20lllu",null,null,null,1,0],[1,0.059138089418411255,7.105427198782324e-17,3.552713599391162e-17],[3,-2.7870760279218907e-7,3.283059300184252e-7,0.17734369636715483,0.9841489792499147],[1,-0.00004066078643605048,0.00004555410153071929,20.430151404605606]]],[0,"41vXcM2stUlqxh5mno+r/p",null,null,null,1,0],[1,0.024493694305419922,-0.019416121765971184,-1.1126012111617456e-7],[3,-0.07887344713377949,-0.1415787173324277,-0.48024108433533635,0.8620341913475126],[1,-27.328014583243206,-32.67734533597021,-53.67161243899926]],[2,"bone_glass_1",5,[[3,"bone_glass_2",-97,[0,"2buY3BvNBSBaopvkwGHPXN",null,null,null,1,0],[1,0.03170768916606903,7.629394360719743e-8,3.552713599391162e-17],[3,1.3331711495618886e-7,-1.6889738596634469e-7,0.442985741246988,0.8965286571280421],[1,0.00003665666563841168,-0.0000397004542909064,52.58907783840186]]],[0,"70UmkW7dNXc5J6VeC2zG7z",null,null,null,1,0],[1,0.1017768457531929,-0.15347406268119812,-0.010790174826979637],[3,-0.22132702192212214,-0.10537596056641846,0.9341430076630262,-0.2593975665577157],[1,159.71314181683314,148.6155320440712,-25.975307118097362]],[2,"bone_glass_3",5,[[3,"bone_glass_4",-98,[0,"3bgPexFXRTWqp9LJM/V3hR",null,null,null,1,0],[1,0.03170764818787575,-3.814697180359872e-8,0],[3,3.595232636765291e-8,-2.8152581342680248e-8,-0.44298581282699345,0.8965286217595096],[1,0.0000037273309989694994,-0.000001756657173224469,-52.589086987546565]]],[0,"a8UpascFNeF7+URWHEGlI2",null,null,null,1,0],[1,0.10177680850028992,-0.15347407758235931,0.010793494060635567],[3,-0.25939792526599226,0.9341431903677219,-0.10537442618570475,-0.22132656090796282],[1,20.28667824175167,-148.61561489804782,-25.975405352260008]],[5,"bone_scarf_1_1",10,[-99],[0,"4ctqmPs8tW0pdYDg+RYPMr",null,null,null,1,0],[1,0.05080268904566765,0.12496548891067505,0.08056779205799103],[3,0.06556572033070104,0.5113201151508253,0.8550221340941054,0.05648031842000247],[1,-118.4997510434669,-176.841174625236,9.417889253138322]],[2,"bone_scarf_1_2",61,[[3,"bone_scarf_1_3",-100,[0,"26A7di0CRcSp89tREgN2tJ",null,null,null,1,0],[1,0.0655302032828331,1.895427743647815e-7,9.536743306171047e-8],[3,-0.01537628334889535,-0.011337746542868893,-0.004093179828228002,0.9998091174282209],[1,-1.7673083340618128,-1.3063274859861882,-0.448981898734146]]],[0,"3aihbrgU1XcJThINP1LKCh",null,null,null,1,0],[1,0.08224750310182571,-1.609325472884393e-8,-1.907348590179936e-8],[3,0.00373036757305692,0.04754115933036558,0.005846675851899097,0.998845202675959],[1,0.3951551331900145,5.447623133347445,0.6895450099223458]],[74,"Point001",10,[[70,"bone_rooster_man_umbrella_guanbi",-101,[0,"e5VrA3eCdX5ZiyTTZLgzKP",null,null,null,1,0],[1,4.724874496459961,4.724874019622803,4.724874019622803]]],[0,"5fNQ/OwnhT5YTvLjd946wh",null,null,null,1,0],[1,0.15537647902965546,-0.17497843503952026,-0.023606223985552788],[3,0.525367622324751,0.47327384777668896,0.5115187810100547,-0.4882102652520456],[1,0.21164584159851074,0.21164582669734955,0.21164582669734955],[1,-94.31991817626152,-88.35418898006004,-0.12444236478068255]],[5,"bone_thigh_l",9,[-102],[0,"27UTN1HCdVM5BXIndBxjhS",null,null,null,1,0],[1,-0.08686263859272003,-0.01716068759560585,0.07113271206617355],[3,0.1579162340430127,0.9873387882310707,-0.00145596627694048,0.014915107853247645],[1,0.45743832025094266,178.19593320933225,18.167150297379237]],[5,"bone_calf_l",64,[7],[0,"46TK4RAcZS5rm5xupsDLkD",null,null,null,1,0],[1,0.07096128165721893,0,4.76837147544984e-9],[3,-1.313515437890413e-20,-1.756925236944928e-19,-0.07455409846782747,0.9972169705744329],[1,-3.0357246158213365e-18,-2.041602430772394e-17,-8.551204599341329]],[2,"bone_toe_0_l",7,[[22,"bone_toe_01_l",-103,[0,"f4FzGuAzVUM7VCgpUC+mff",null,null,null,1,0],[1,0.024867605417966843,0,0]]],[0,"80k8EndHRdQ6LJ6CqKWFdl",null,null,null,1,0],[1,0.021870195865631104,0.02208235114812851,-0.02110855095088482],[3,-0.027035383521456725,0.02703541518642428,0.7065897587580596,0.7065897587580596],[1,-89.99999871617963,90.00000128382086,85.6176578466992]],[2,"bone_toe_1_l",7,[[22,"bone_toe_11_l",-104,[0,"64pqF83IpeX6L/i9mnRFi/",null,null,null,1,0],[1,0.02885168045759201,0,-4.76837147544984e-9]]],[0,"aaiB5uigJS9ZXpbIKzl5AR",null,null,null,1,0],[1,0.021870195865631104,0.02100020833313465,0.0004183435521554202],[3,1.5454310096341944e-8,1.5454310096341944e-8,0.7071067811865474,0.7071067811865474],[1,0,0.0000025044781562438674,90]],[2,"bone_toe_2_l",7,[[22,"bone_toe_21_l",-105,[0,"10Qn/eaNJaob4kC9ran0Cs",null,null,null,1,0],[1,0.025741711258888245,1.3877787497621727e-19,1.776356799695581e-17]]],[0,"51Jf49Cg9bo7SES1OrfXIA",null,null,null,1,0],[1,0.021870195865631104,0.022662734612822533,0.021613387390971184],[3,0.03131237990885805,-0.031312350106535734,0.7064131480922652,0.7064131480922652],[1,90.00000120860393,-89.99999879139624,84.92395415644309]],[2,"bone_toe_3_l",7,[[3,"bone_toe_31_l",-106,[0,"c9WCktTdVXPbWDojS0WNZh",null,null,null,1,0],[1,0.015805143862962723,-5.9604643443123e-10,-8.881783998477905e-18],[3,-1.5729424943978037e-11,1.8542201387007867e-10,-0.02021330252917722,0.9997956903292113],[1,-1.3737254520174583e-9,2.12243664623144e-8,-2.316431608494563]]],[0,"46N4CrtsdZw7+2ZkfWiTt0",null,null,null,1,0],[1,0.018188951537013054,-0.015943314880132675,-0.0000347328168572858],[3,0.7236944459089776,-0.6901177784978072,-0.001345440283794167,-0.0014108693037353502],[1,-175.30445882542233,4.690238056337621,-87.26992422192123]],[5,"bone_thigh_r",9,[-107],[0,"881cnf5lxbjblYd0D1giLA",null,null,null,1,0],[1,-0.08686263859272003,-0.017160287126898766,-0.0711326152086258],[3,0.15791617447106315,0.9873387884354936,0.0014586990105260873,-0.0149154580336263],[1,-0.4577702658141898,-178.1958395538103,18.167138230364852]],[5,"bone_calf_r",70,[8],[0,"f9hyaqT1xTFLSlasj9sJTL",null,null,null,1,0],[1,0.07096127420663834,-4.76837147544984e-9,-4.76837147544984e-9],[3,8.075896951739903e-19,3.530872454534643e-18,-0.07455409846782747,0.9972169705744329],[1,1.238271507476479e-16,4.1499494401816016e-16,-8.551204599341329]],[2,"bone_toe_0_r",8,[[22,"bone_toe_01_r",-108,[0,"b05ITXemxbZ6Llfgp6K/HI",null,null,null,1,0],[1,0.024867605417966843,0,0]]],[0,"b2GXeWA5pdy6WhtnUu+0/C",null,null,null,1,0],[1,0.021870195865631104,0.02208235114812851,0.02110855095088482],[3,0.027035389101223585,-0.02703542076619113,0.7065897585445675,0.7065897585445675],[1,89.99999871617939,-90.00000128382062,85.61765694179734]],[2,"bone_toe_1_r",8,[[22,"bone_toe_11_r",-109,[0,"5bYgxvxAJWdo4YPd+mA6mz",null,null,null,1,0],[1,0.02885168045759201,0,-4.76837147544984e-9]]],[0,"a1I4+Lk6ZfebcipF/wQhR0",null,null,null,1,0],[1,0.021870195865631104,0.02100020833313465,-0.0004183435521554202],[3,-1.5454308319985075e-8,-1.5454308319985075e-8,0.7071067811865474,0.7071067811865474],[1,0,-0.0000025044778683729144,90]],[2,"bone_toe_2_r",8,[[22,"bone_toe_21_r",-110,[0,"32CLe5aeFXibHa6k3kmIjy",null,null,null,1,0],[1,0.025741711258888245,1.3877787497621727e-19,4.76837147544984e-9]]],[0,"c0iiuFxidV+oNn8vMilEIe",null,null,null,1,0],[1,0.021870195865631104,0.02266274020075798,-0.02161339670419693],[3,-0.03131237990885805,0.031312350106535734,0.7064131480922652,0.7064131480922652],[1,-90.00000120860393,89.99999879139624,84.92395415644309]],[2,"bone_toe_3_r",8,[[3,"bone_toe_31_r",-111,[0,"df+Br0PLpV74donVEVJhGn",null,null,null,1,0],[1,0.01580514945089817,-5.9604643443123e-10,8.881783998477905e-18],[3,-1.8630394816590416e-12,6.761676043174392e-11,-0.02021330252917722,0.9997956903292113],[1,-5.687252061909582e-11,7.748743555952291e-9,-2.316431608494563]]],[0,"cbvPSroNNTWL0BieL3/ale",null,null,null,1,0],[1,0.018188951537013054,-0.01594330556690693,0.00003472805110504851],[3,0.7236945040651529,-0.6901177175118963,0.0013454402811012775,0.0014108694173268269],[1,175.30447521035822,-4.6902216619660875,-87.26991459691776]],[5,"bone_tail_1_1",12,[-112],[0,"1eGPXnl6BWS6lX2fh3Te2p",null,null,null,1,0],[1,0.09104113280773163,-0.10881961137056351,4.76837158203125e-7],[3,-0.689225309422498,0.7245470811815092,-0.000001622224870384012,-4.312115281140967e-7],[1,0.0033791666198131737,-179.9967173694822,-87.13763327652617]],[2,"bone_tail_1_2",76,[[3,"bone_tail_1_3",-113,[0,"143dkmW4tYK4yIK4e9rSSw",null,null,null,1,0],[1,0.09709915518760681,1.907348590179936e-8,4.5474734072206875e-15],[3,-4.142893599589412e-15,-1.3593558193462817e-14,-0.2915302198647889,0.9565616189799734],[1,-1.094235147497382e-12,-1.9619328248155237e-12,-33.899180562937254]]],[0,"bc9U1KsfxQ1oPreVQej7re",null,null,null,1,0],[1,0.09229078888893127,-0.000002918243353633443,-8.058229639118508e-9],[3,7.676782909373915e-9,3.799760222413581e-8,-0.19803236797272605,0.9801954811337958],[1,0.0000018713204917247753,0.000004820249223008809,-22.84384159860921]],[71,"rooster_man_umbrella_guanbi",1,[[28,1,-114,[1,"32hFEfVZNdLIwbllHXTrT2"],[6],[26,true,true],1,7,8]],[0,"71ubkNVSlTgLnWiRjML0Un",null,null,null,1,0],[1,-0.23248745501041412,0.4622747302055359,-0.1481768637895584],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]],[32,"rooster_man_umbrella",1,[[28,1,-115,[1,"fbk3tgLaNcQK5x7O+rdFIQ"],[9],[26,true,true],1,10,11]],[0,"71ftPCp5RWdqivKpNJIDZd",null,null,null,1,0]]],0,[0,8,1,0,0,1,0,-1,18,0,-2,19,0,-3,20,0,-4,78,0,-5,79,0,-1,35,0,-2,37,0,-3,39,0,-4,41,0,-5,43,0,-6,45,0,-7,47,0,-8,49,0,-1,29,0,-2,30,0,-3,31,0,-4,32,0,-5,33,0,-1,22,0,-2,23,0,-3,24,0,-4,25,0,1,5,0,-2,6,0,-3,59,0,-4,60,0,-1,53,0,-2,55,0,-3,56,0,-4,17,0,-1,66,0,-2,67,0,-3,68,0,-4,69,0,-1,72,0,-2,73,0,-3,74,0,-4,75,0,-1,10,0,-2,64,0,-3,70,0,-1,11,0,-2,61,0,-3,63,0,-1,13,0,-2,15,0,-2,76,0,-1,14,0,-2,27,0,-1,21,0,-2,26,0,-1,16,0,-2,52,0,-1,28,0,-2,51,0,-1,57,0,-2,58,0,0,18,0,0,19,0,1,22,0,1,23,0,1,24,0,1,25,0,1,26,0,1,27,0,1,29,0,1,30,0,1,31,0,1,32,0,-1,34,0,-1,36,0,1,36,0,-1,38,0,1,38,0,-1,40,0,1,40,0,-1,42,0,1,42,0,-1,44,0,1,44,0,-1,46,0,1,46,0,-1,48,0,1,48,0,-1,50,0,1,50,0,1,51,0,1,52,0,-1,54,0,1,54,0,1,55,0,1,56,0,1,57,0,1,58,0,1,59,0,1,60,0,-1,62,0,1,62,0,1,63,0,-1,65,0,1,66,0,1,67,0,1,68,0,1,69,0,-1,71,0,1,72,0,1,73,0,1,74,0,1,75,0,-1,77,0,1,77,0,0,78,0,0,79,0,18,1,2,1,34,3,1,28,4,1,21,5,1,11,7,1,65,8,1,71,9,1,12,12,1,20,115],[0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,12,-1,2,12,-1,2,12,-1,2,12],[6,33,34,6,35,36,6,37,38,6,39,40]],[[[10,".bin",1693677031,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":34704,"length":2988,"count":1494,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":34704,"count":482,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4]]},"minPosition",8,[1,-0.14031574130058289,0.49468445777893066,-0.20554518699645996],"maxPosition",8,[1,0.1403157263994217,0.6229018568992615,0.1685122400522232]]],-1],0,0,[],[],[]],[[[27,"Skin-2",3586338488,["bone_root/bone_pelvis/bone_spine/bone_spine1/Point001/bone_rooster_man_umbrella_guanbi"],[[[7,0.9995851516723633,-0.02880270406603813,9.05781405435846e-9,0,9.313225746154785e-10,-2.821568045874301e-7,-1,0,0.02880270406603813,0.9995851516723633,-2.8201290547258395e-7,0,-0.20906183123588562,-0.0032492117024958134,0.00038516116910614073,1]],8]]],0,0,[],[],[]],[[[27,"Skin-3",2873805602,["bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_23","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_19","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_03","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_15","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_11","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_07","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_31","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_27","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_23/bone_umbrella_24","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_19/bone_umbrella_20","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_03/bone_umbrella_04","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_15/bone_umbrella_16","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_11/bone_umbrella_12","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_07/bone_umbrella_08","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_23/bone_umbrella_24/bone_umbrella_25","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_19/bone_umbrella_20/bone_umbrella_21","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_27/bone_umbrella_28","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_31/bone_umbrella_32","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_03/bone_umbrella_04/bone_umbrella_05","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_15/bone_umbrella_16/bone_umbrella_17","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_11/bone_umbrella_12/bone_umbrella_13","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_07/bone_umbrella_08/bone_umbrella_09","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_27/bone_umbrella_28/bone_umbrella_29","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/Point002/bone_umbrella_01/bone_umbrella_02/bone_umbrella_31/bone_umbrella_32/bone_umbrella_33"],[[[7,1.6298186267249548e-7,-1,4.371031536720693e-8,0,1,1.6298186267249548e-7,4.371138118131057e-8,0,-4.371138828673793e-8,4.3710308261779574e-8,1,0,-0.35453087091445923,-0.0004798775480594486,-1.5297685340698308e-9,1],[7,0.008403039537370205,-0.9999646544456482,4.370984640900133e-8,0,0.9999646544456482,0.008403039537370205,4.33440803249141e-8,0,-4.370984285628765e-8,4.33440803249141e-8,1,0,-0.0378875806927681,-0.005918022245168686,-1.3995491432439167e-9,1],[7,-0.36874380707740784,-0.11507276445627213,-0.9223806858062744,0,-0.31801268458366394,0.9480448365211487,0.008858557790517807,0,0.873439371585846,0.29659518599510193,-0.38618025183677673,0,0.18569763004779816,-0.5712769031524658,-0.004486833233386278,1],[7,0.365786075592041,-0.11521796882152557,0.9235393404960632,0,-0.318412184715271,-0.9479197859764099,0.007853860035538673,0,0.8745365142822266,-0.29693907499313354,-0.3834226131439209,0,0.18556983768939972,0.5713191032409668,-0.004823931492865086,1],[7,-0.870343029499054,0.29559406638145447,0.39386141300201416,0,-0.31900015473365784,-0.9477332830429077,0.006359329912811518,0,0.37515535950660706,-0.12010709196329117,0.9191476702690125,0,0.1850283145904541,0.5715330243110657,-0.0008368942071683705,1],[7,0.8703433871269226,0.295593798160553,-0.3938610255718231,0,-0.3190000355243683,0.9477332234382629,0.00635888148099184,0,0.37515491247177124,0.12010727822780609,0.919147789478302,0,0.1850317269563675,-0.5715318322181702,-0.0008382025407627225,1],[7,0.8703433275222778,-0.2955937385559082,-0.39386144280433655,0,-0.31900012493133545,-0.9477333426475525,0.006358638405799866,0,-0.3751552104949951,0.12010764330625534,-0.919147789478302,0,0.19821226596832275,0.5670554041862488,-0.006802666466683149,1],[7,-0.8703430891036987,-0.2955939471721649,0.3938612937927246,0,-0.319000244140625,0.9477331638336182,0.006358726881444454,0,-0.3751550614833832,-0.12010761350393295,-0.9191476702690125,0,0.18502838909626007,-0.5715329647064209,-0.0008365075918845832,1],[7,0.3687436282634735,0.11507351696491241,0.9223806858062744,0,-0.3180130124092102,0.9480448365211487,0.008857951499521732,0,-0.8734390735626221,-0.29659536480903625,0.38618040084838867,0,0.18407006561756134,-0.5718296766281128,-0.0037643967662006617,1],[7,-0.3687434494495392,0.11507335305213928,-0.9223810434341431,0,-0.31801286339759827,-0.9480448365211487,0.008857950568199158,0,-0.8734393119812012,0.29659518599510193,0.38618025183677673,0,0.1840691715478897,0.5718298554420471,-0.0037664128467440605,1],[7,-0.3327672779560089,-0.17457875609397888,-0.9267082214355469,0,-0.477318674325943,0.8787108659744263,0.005861380137503147,0,0.8132853507995605,0.44428563117980957,-0.3757358193397522,0,0.09468811005353928,-0.5633872747421265,-0.004967241548001766,1],[7,0.3298160135746002,-0.1742066591978073,0.9278327226638794,0,-0.47767943143844604,-0.878520667552948,0.004852308891713619,0,0.8142749667167664,-0.44480690360069275,-0.3729652166366577,0,0.09457360953092575,0.5634497404098511,-0.005305979400873184,1],[7,-0.81049644947052,0.44278550148010254,0.3834528923034668,0,-0.4782090187072754,-0.8782395124435425,0.0033509829081594944,0,0.33824726939201355,-0.18065470457077026,0.9235541820526123,0,0.0940319150686264,0.5637651681900024,-0.0013258439721539617,1],[7,0.8104966878890991,0.442785382270813,-0.3834528625011444,0,-0.47820907831192017,0.8782395124435425,0.0033505549654364586,0,0.33824706077575684,0.18065501749515533,0.9235543012619019,0,0.09403517097234726,-0.563763439655304,-0.0013270112685859203,1],[7,0.8104967474937439,-0.4427853226661682,-0.3834528923034668,0,-0.4782092273235321,-0.8782394528388977,0.003350102109834552,0,-0.3382468819618225,0.18065543472766876,-0.9235543608665466,0,0.1063094437122345,0.5570579171180725,-0.007133884821087122,1],[7,-0.8104966282844543,-0.4427856206893921,0.38345280289649963,0,-0.47820940613746643,0.8782394528388977,0.0033502469304949045,0,-0.33824682235717773,-0.180655375123024,-0.9235543608665466,0,0.09403213858604431,-0.5637651681900024,-0.0013254735385999084,1],[7,-0.23705880343914032,-0.292540967464447,-0.9264034032821655,0,-0.7781475782394409,0.6280809640884399,0.0007852674461901188,0,0.5816262364387512,0.7210648655891418,-0.3765322268009186,0,0.13177579641342163,-0.5553808808326721,-0.0023782041389495134,1],[7,0.2344728261232376,-0.2910686135292053,0.9275245666503906,0,-0.7784042358398438,-0.6277630925178528,-0.00022368280042428523,0,0.5823306441307068,-0.7219365239143372,-0.3737626075744629,0,0.13169510662555695,0.5554838180541992,-0.002716714283451438,1],[7,-0.33276689052581787,0.17457881569862366,-0.9267085790634155,0,-0.47731882333755493,-0.8787106871604919,0.005861223209649324,0,-0.8132852911949158,0.4442858099937439,0.37573564052581787,0,0.09317179024219513,0.5642156004905701,-0.0042665316723287106,1],[7,0.33276697993278503,0.17457908391952515,0.9267083406448364,0,-0.4773190915584564,0.8787104487419128,0.005861090496182442,0,-0.8132851719856262,-0.44428589940071106,0.3757357597351074,0,0.09317263960838318,-0.5642150640487671,-0.004264371003955603,1],[7,-0.5796542167663574,0.7185786962509155,0.38424670696258545,0,-0.7787802219390869,-0.6272944808006287,-0.0017247908981516957,0,0.2397965043783188,-0.3002435863018036,0.9232286214828491,0,0.13130241632461548,0.5559678673744202,0.0012642123037949204,1],[7,0.5796540975570679,0.7185789942741394,-0.38424649834632874,0,-0.778780460357666,0.6272942423820496,-0.0017252269899472594,0,0.23979587852954865,0.3002437353134155,0.9232288599014282,0,0.13130497932434082,-0.5559649467468262,0.001262895530089736,1],[7,0.579654335975647,-0.7185785174369812,-0.38424667716026306,0,-0.7787801027297974,-0.6272945404052734,-0.001725106267258525,0,-0.2397962510585785,0.30024367570877075,-0.9232287406921387,0,0.14008291065692902,0.5450827479362488,-0.004555972758680582,1],[7,-0.5796541571617126,-0.718578577041626,0.3842465579509735,0,-0.7787799835205078,0.6272943615913391,-0.0017250849632546306,0,-0.23979613184928894,-0.3002435863018036,-0.9232286214828491,0,0.13130229711532593,-0.5559675693511963,0.001264513935893774,1],[7,-0.2370586395263672,0.2925410866737366,-0.9264032244682312,0,-0.7781476974487305,-0.6280809044837952,0.0007849502144381404,0,-0.5816265344619751,0.7210646271705627,0.3765321671962738,0,0.1306912750005722,0.5567252039909363,-0.001675864914432168,1],[7,0.23705868422985077,0.2925412654876709,0.9264029860496521,0,-0.7781481146812439,0.628080427646637,0.0007850687252357602,0,-0.5816260576248169,-0.7210648655891418,0.37653225660324097,0,0.1306920200586319,-0.5567243695259094,-0.001673865714110434,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[10,".bin",661063935,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":66600,"length":7584,"count":3792,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":66600,"count":925,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]]},"minPosition",8,[1,-0.44668471813201904,0.0013563621323555708,-0.5867345929145813],"maxPosition",8,[1,0.44668471813201904,0.7064724564552307,0.44668492674827576]]],-1],0,0,[],[],[]],[[[10,".bin",1865081629,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":56664,"length":7056,"count":3528,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":56664,"count":787,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.00027738368953578174,-0.030230842530727386,-0.03849217668175697],"maxPosition",8,[1,0.48211410641670227,0.030093496665358543,0.07630427181720734]]],-1],0,0,[],[],[]],[[[27,"Skin-1",1437921904,["bone_root/bone_pelvis/bone_spine","bone_root/bone_pelvis/bone_spine/bone_spine1","bone_root/bone_pelvis","bone_root/bone_pelvis/bone_tail_1_1","bone_root/bone_pelvis/bone_tail_1_1/bone_tail_1_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_beak/bone_beard_2_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_beak/bone_beard_2_1/bone_beard_2_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_beak","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_beak/bone_beard_1_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_beak/bone_beard_1_1/bone_beard_1_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_scarf_1_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_scarf_1_1/bone_scarf_1_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_scarf_1_1/bone_scarf_1_2/bone_scarf_1_3","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_1_1/bone_hair_1_2/bone_hair_1_3","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_root_uparmtwist_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r","bone_root/bone_pelvis/bone_tail_1_1/bone_tail_1_2/bone_tail_1_3","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_2_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_3_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_3_1/bone_hair_3_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_1_1","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_1_1/bone_hair_1_2","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_head/bone_ head_zhuandong/bone_hair_2_1/bone_hair_2_2","bone_root/bone_pelvis/bone_spine/bone_thigh_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_1_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_3_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_0_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_3_l/bone_toe_31_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_2_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_1_l/bone_toe_11_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_0_l/bone_toe_01_l","bone_root/bone_pelvis/bone_spine/bone_thigh_l/bone_calf_l/bone_foot_l/bone_toe_2_l/bone_toe_21_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_0_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_0_l/bone_finger_01_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_1_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_2_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_root_foretwist_l/bone_root_foretwist_1_l ","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_1_l/bone_finger_11_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_3_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_2_l/bone_finger_21_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_upperarm_l/bone_forearm_l/bone_hand_l/bone_finger_3_l/bone_finger_31_l","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_l/bone_root_uparmtwist_l","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_1_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_3_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_0_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_3_r/bone_toe_31_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_2_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_1_r/bone_toe_11_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_0_r/bone_toe_01_r","bone_root/bone_pelvis/bone_spine/bone_thigh_r/bone_calf_r/bone_foot_r/bone_toe_2_r/bone_toe_21_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_0_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_0_r/bone_finger_01_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_1_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_2_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_root_for_twist_r/bone_root_for_twist_1_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_1_r/bone_finger_11_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_3_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_2_r/bone_finger_21_r","bone_root/bone_pelvis/bone_spine/bone_spine1/bone_neck/bone_clavicle_r/bone_upperarm_r/bone_forearm_r/bone_hand_r/bone_finger_3_r/bone_finger_31_r"],[[[7,3.0196633815648966e-7,-0.000001436363618267933,1,0,0.9754394888877869,-0.22026759386062622,-6.109342507443216e-7,0,0.22026757895946503,0.9754395484924316,0.0000013345724028113182,0,-0.2171524167060852,0.05288885161280632,1.8437279436511744e-7,1],[7,1.0330492017374127e-7,-0.0000014065908544580452,1,0,0.9971567988395691,-0.0753551721572876,-2.0900509412058454e-7,0,0.075355164706707,0.9971568584442139,0.0000013948069863545243,0,-0.3036320209503174,0.008694549091160297,6.179546119255974e-8,1],[7,0.0000013868000223737909,0.0000027577070795814507,1,0,1,4.370756556681954e-8,-0.0000013868002497474663,0,-4.371138828673793e-8,1,-0.0000027577070795814507,0,-0.14251941442489624,0.03963029757142067,8.835717579813718e-8,1],[7,1.760090810876136e-7,-2.335713560341901e-7,-1,0,-0.049937013536691666,-0.9987524151802063,2.244905914494666e-7,0,-0.9987524151802063,0.04993700981140137,-1.8745333818515064e-7,0,-0.13660140335559845,0.24068228900432587,-2.977090396427684e-8,1],[7,3.304120355096529e-7,-1.4692109573388734e-7,-1,0,0.3417162597179413,-0.9398031830787659,2.50984072636129e-7,0,-0.9398031830787659,-0.3417162597179413,-2.603169377835002e-7,0,-0.30437836050987244,0.1329466551542282,-4.531133868113102e-8,1],[7,-1.3988815794618858e-7,-0.000001231492547049129,1,0,0.9971639513969421,0.07525794953107834,2.321711036756824e-7,0,-0.07525794953107834,0.9971640110015869,0.0000012174725725344615,0,-0.44831836223602295,-0.051258910447359085,-1.6472750985485618e-7,1],[7,-0.9467975497245789,-0.052622970193624496,0.31749847531318665,0,-0.32077401876449585,0.0744577944278717,-0.9442246556282043,0,0.026047667488455772,-0.9958348274230957,-0.08737653493881226,0,0.017055559903383255,0.015561139211058617,0.38688793778419495,1],[7,-0.539751410484314,-0.07264070212841034,0.8386845588684082,0,-0.8405380249023438,-0.008552946150302887,-0.5416850447654724,0,0.04652160406112671,-0.9973215460777283,-0.0564408041536808,0,0.22811709344387054,0.042848773300647736,0.31017494201660156,1],[7,0.9467976093292236,0.052620235830545425,0.31749868392944336,0,-0.32077398896217346,0.0744578018784523,0.9442246556282043,0,0.026045067235827446,-0.9958349466323853,0.08737567067146301,0,0.017055625095963478,0.01556114200502634,-0.38688793778419495,1],[7,0.5397515296936035,0.07263796031475067,0.8386847376823425,0,-0.8405380249023438,-0.008552945218980312,0.5416850447654724,0,0.04652012139558792,-0.9973217248916626,0.05643850564956665,0,0.22811713814735413,0.042848773300647736,-0.3101748824119568,1],[7,-0.3198479413986206,-9.535537515148462e-7,-0.9474689364433289,0,-0.819725751876831,0.5014714002609253,0.2767237722873688,0,0.47512826323509216,0.8651742339134216,-0.16039538383483887,0,0.32399678230285645,-0.35484886169433594,-0.10937494784593582,1],[7,-0.2997286021709442,0.11164730787277222,-0.9474690556526184,0,-0.5931175947189331,0.7560654878616333,0.276723712682724,0,0.7472440600395203,0.6449025869369507,-0.1603945642709732,0,0.12433332204818726,-0.42498111724853516,-0.10937505960464478,1],[7,-2.565705301549315e-7,-1.1630544349827687e-7,-1,0,-0.028934836387634277,0.9995813369750977,-1.0883292134167277e-7,0,0.9995813369750977,0.028934836387634277,-2.5982839702010097e-7,0,-0.09726302325725555,-0.49694088101387024,-3.0657043570414544e-9,1],[7,0.31984806060791016,-5.688063424713619e-7,0.947468638420105,0,-0.819725751876831,-0.5014712810516357,0.2767239809036255,0,0.47512826323509216,-0.8651742935180664,-0.1603950411081314,0,0.32399675250053406,0.35484883189201355,-0.10937513411045074,1],[7,0.29972872138023376,0.1116473600268364,0.9474689364433289,0,-0.5931175351142883,-0.7560656666755676,0.276723712682724,0,0.7472442984580994,-0.6449025273323059,-0.16039462387561798,0,0.1243332177400589,0.42498108744621277,-0.10937508940696716,1],[7,0.054360922425985336,0.8817869424819946,0.46850451827049255,0,-0.9945524334907532,0.006021528039127588,0.10406526923179626,0,0.08894231915473938,-0.47160932421684265,0.8773104548454285,0,0.3257204592227936,-0.005844303406774998,-0.19876137375831604,1],[7,0.02024874836206436,0.8848370313644409,0.46546027064323425,0,-0.9997950196266174,0.0181177519261837,0.009051963686943054,0,-0.0004235815431457013,-0.4655480682849884,0.8850224018096924,0,0.26115360856056213,-0.010192329995334148,-0.17468324303627014,1],[7,0.02392021380364895,0.8702946901321411,0.49195000529289246,0,-0.99944007396698,0.009299395605921745,0.03214472159743309,0,0.023400550708174706,-0.49244341254234314,0.8700297474861145,0,0.19166412949562073,-0.0031636711210012436,-0.17928053438663483,1],[7,0.3306330442428589,-0.8999735116958618,0.28412944078445435,0,-0.9254514575004578,-0.36818915605545044,-0.08931005001068115,0,0.1849900484085083,-0.23341917991638184,-0.9546172618865967,0,0.16406424343585968,0.2882530093193054,0.027363676577806473,1],[7,-8.802777529126615e-8,6.28301037863821e-8,-1,0,-0.9919980764389038,-0.12625263631343842,7.939092938613612e-8,0,-0.12625263631343842,0.9919981956481934,7.34410861014112e-8,0,0.6436730027198792,0.2737114727497101,3.699202366647114e-8,1],[7,-0.5224653482437134,-0.15374724566936493,0.8386845588684082,0,-0.8294952511787415,-0.13606977462768555,-0.5416850447654724,0,0.19740217924118042,-0.9786965847015381,-0.05644085630774498,0,0.1526317149400711,0.0667966827750206,0.31017494201660156,1],[7,-0.539751410484314,-0.12315724045038223,0.8327668905258179,0,-0.8405380249023438,0.024175643920898438,-0.5412128567695618,0,0.04652160406112671,-0.9920927882194519,-0.11656716465950012,0,0.22811709344387054,0.024038776755332947,0.3121964931488037,1],[7,-0.3306325078010559,0.8999729156494141,0.28413209319114685,0,-0.9254515171051025,-0.36818915605545044,0.08931005746126175,0,0.18499097228050232,-0.2334216833114624,0.9546165466308594,0,0.1640642285346985,0.2882530689239502,-0.02736365608870983,1],[7,3.5619149230115e-7,6.233430838165077e-8,-1,0,0.8077908158302307,-0.5894692540168762,2.50984072636129e-7,0,-0.5894691944122314,-0.8077908754348755,-2.6031702304862847e-7,0,-0.4073832035064697,-0.11356889456510544,-4.531135644469941e-8,1],[7,0.5224658846855164,0.15374454855918884,0.8386846780776978,0,-0.8294951915740967,-0.13606977462768555,0.5416851043701172,0,0.19740073382854462,-0.9786969423294067,0.056438546627759933,0,0.1526317447423935,0.0667966827750206,-0.3101749122142792,1],[7,-4.37458318458539e-8,1.2184030140360846e-7,-1,0,0.851658046245575,-0.5240978598594666,-1.011127537253742e-7,0,-0.5240979194641113,-0.8516579270362854,-8.083919311729915e-8,0,-0.5938234329223633,0.3578529953956604,1.9660751604533289e-7,1],[7,-2.2057075454995356e-7,0.0000018838289861378144,-1,0,0.9967919588088989,-0.08003509044647217,-3.7063563240735675e-7,0,-0.08003508299589157,-0.9967920184135437,-0.0000018601325564304716,0,-0.6781166791915894,0.1129223182797432,4.775531010636769e-7,1],[7,-9.422133473435679e-8,3.181864940415835e-7,-1,0,0.9211397171020508,-0.3892318904399872,-2.1063938504539692e-7,0,-0.3892318606376648,-0.9211397767066956,-2.564203214205918e-7,0,-0.6507955193519592,0.33438292145729065,2.7266048618912464e-7,1],[7,-6.864804191764051e-8,-1.776609650505634e-7,-1,0,0.6591029167175293,-0.7520528435707092,8.836430254177685e-8,0,-0.7520528435707092,-0.6591029167175293,1.68723801152737e-7,0,-0.4912315607070923,0.44193822145462036,3.8550908243450976e-8,1],[7,-2.773175253878435e-7,1.0211908829660388e-7,-1,0,-0.530916690826416,-0.8474240303039551,6.069433311495231e-8,0,-0.8474240303039551,0.530916690826416,2.8922227102157194e-7,0,0.25995975732803345,0.6713935136795044,7.959089032283373e-8,1],[7,2.3086890621470957e-8,5.370113242975094e-9,-1.0000001192092896,0,0.4751512408256531,-0.8799041509628296,6.244575967429e-9,0,-0.8799043297767639,-0.4751511514186859,-2.286586564537174e-8,0,-0.3953912556171417,0.6418036222457886,1.1394980248269349e-7,1],[7,-0.029913099482655525,0.0018343391129747033,-0.9995508790016174,0,-0.9950326085090637,0.09493601322174072,0.029952114447951317,0,0.09494830667972565,0.9954817295074463,-0.001014603185467422,0,0.14770209789276123,0.0257906261831522,0.06679174304008484,1],[7,-0.029853327199816704,-0.002633852418512106,-0.9995508790016174,0,-0.9980875253677368,-0.0540739931166172,0.029952116310596466,0,-0.054128583520650864,0.9985335469245911,-0.0010145265841856599,0,0.07205282151699066,0.03691476210951805,0.06679174304008484,1],[7,0.029853003099560738,0.0026366012170910835,-0.9995508790016174,0,-0.9980875253677368,-0.0540739931166172,-0.029951943084597588,0,-0.05412866920232773,0.9985335469245911,0.001017287839204073,0,0.07205280661582947,0.03691476210951805,-0.06679166108369827,1],[7,0.02991318702697754,-0.0018315742490813136,-0.9995508790016174,0,-0.9950326681137085,0.09493600577116013,-0.02995193749666214,0,0.09494821727275848,0.9954817295074463,0.0010173623450100422,0,0.14770208299160004,0.025790629908442497,-0.06679166108369827,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-1,4.371145223558415e-8,-4.371133144331907e-8,0,4.371138828673793e-8,1,0.000001370906943520822,0,0.022648802027106285,0.03556423261761665,0.06753659248352051,1],[7,0.0000013716037301492179,-4.3711455788297826e-8,-1,0,4.371139183945161e-8,1,-4.3711398944878965e-8,0,1,-4.371132789060539e-8,0.0000013716037301492179,0,0.014564022421836853,-0.0007786036585457623,0.06711824238300323,1],[7,0.003893338143825531,0.00018498663848731667,0.9999922513961792,0,-0.04747134447097778,0.9988725185394287,4.388856567061339e-8,0,-0.998865008354187,-0.047470979392528534,0.0038977297954261303,0,-0.05150053650140762,-0.006912440061569214,-0.0673699602484703,1],[7,0.0764131173491478,-4.4572786350727256e-8,-0.9970763325691223,0,-1.0649818302420019e-15,1,-4.4703490686970326e-8,0,0.9970762729644775,3.415933758077472e-9,0.0764131173491478,0,0.006668933667242527,-0.0007786019705235958,0.08941614627838135,1],[7,0.003882679855450988,0.0003421977744437754,0.9999922513961792,0,-0.08780533820390701,0.9961376190185547,4.388856567061339e-8,0,-0.996130108833313,-0.08780466020107269,0.0038977297954261303,0,-0.0669712945818901,-0.009627175517380238,-0.0673699602484703,1],[7,-0.0884765088558197,-4.452817137234888e-8,-0.9960783123970032,0,1.41152534945772e-15,1,-4.4703490686970326e-8,0,0.9960783123970032,-3.955209493256007e-9,-0.0884765088558197,0,0.016914082691073418,-0.0007786039495840669,0.044601596891880035,1],[7,0.0000013716037301492179,-4.3711455788297826e-8,-1,0,4.371139183945161e-8,1,-4.3711398944878965e-8,0,1,-4.371132789060539e-8,0.0000013716037301492179,0,-0.014287659898400307,-0.0007786024361848831,0.06711824983358383,1],[7,0.0764131173491478,-4.4572786350727256e-8,-0.9970763325691223,0,-1.0649818302420019e-15,1,-4.4703490686970326e-8,0,0.9970762729644775,3.415933758077472e-9,0.0764131173491478,0,-0.01819867081940174,-0.0007786019123159349,0.08941613882780075,1],[7,-0.0884765088558197,-4.452817137234888e-8,-0.9960783123970032,0,1.41152534945772e-15,1,-4.4703490686970326e-8,0,0.9960783123970032,-3.955209493256007e-9,-0.0884765088558197,0,-0.008827628567814827,-0.0007786040077917278,0.044601596891880035,1],[7,-0.32235226035118103,0.09166663885116577,0.9421711564064026,0,-0.498395174741745,-0.8626145124435425,-0.08659343421459198,0,0.8047927618026733,-0.49748703837394714,0.3237519860267639,0,0.09446684271097183,0.24517127871513367,-0.19150584936141968,1],[7,-0.2713765501976013,0.19664296507835388,0.9421711564064026,0,-0.7639675140380859,-0.6394180059432983,-0.08659342676401138,0,0.5854130983352661,-0.7432875633239746,0.32375186681747437,0,0.14383327960968018,0.2084914892911911,-0.19150584936141968,1],[7,0.2807330787181854,-0.9174687266349792,0.2818513810634613,0,-0.9442408084869385,-0.3166476786136627,-0.09024138003587723,0,0.17204120755195618,-0.2408018708229065,-0.9552048444747925,0,0.12403224408626556,0.28176742792129517,0.06136443093419075,1],[7,0.27511975169181824,-0.9290263056755066,0.24742518365383148,0,-0.9499455094337463,-0.30230796337127686,-0.07882489264011383,0,0.14802899956703186,-0.2133541703224182,-0.9656952619552612,0,0.13115914165973663,0.2804591953754425,0.03373662009835243,1],[7,0.5224658846855164,0.22934690117835999,0.8212364912033081,0,-0.8294951915740967,-0.08626563847064972,0.5518115162849426,0,0.19740073382854462,-0.9695144295692444,0.14517129957675934,0,0.12652884423732758,0.038324352353811264,-0.3149627149105072,1],[7,0.07405158877372742,-0.9565962553024292,0.281851202249527,0,-0.9905513525009155,-0.1032688170671463,-0.09024139493703842,0,0.11543101072311401,-0.27250561118125916,-0.9552049040794373,0,0.1517685502767563,0.2548181712627411,0.06136448681354523,1],[7,0.3089147210121155,-0.9275990128517151,0.2100759893655777,0,-0.9414753913879395,-0.32956624031066895,-0.07078197598457336,0,0.13489124178886414,-0.17591583728790283,-0.9751193523406982,0,0.12360800802707672,0.28386932611465454,0.008615207858383656,1],[7,0.08077391237020493,-0.9655342102050781,0.24742524325847626,0,-0.9915376305580139,-0.10314875096082687,-0.07882487773895264,0,0.10162971913814545,-0.23896446824073792,-0.9656952619552612,0,0.15007562935352325,0.2553071677684784,0.03373660892248154,1],[7,0.0631500855088234,-0.9756436347961426,0.21007564663887024,0,-0.994310736656189,-0.07959915697574615,-0.07078200578689575,0,0.08577985316514969,-0.2044106274843216,-0.975119411945343,0,0.15829570591449738,0.25192204117774963,0.008615299127995968,1],[7,0.5397515296936035,0.12315449863672256,0.8327671885490417,0,-0.8405380249023438,0.02417563833296299,0.5412128567695618,0,0.04652012139558792,-0.992093026638031,0.11656486988067627,0,0.22811713814735413,0.02403879165649414,-0.31219643354415894,1],[7,4.371138828673793e-8,0.000001370906943520822,-1,0,-1,4.371145223558415e-8,-4.371133144331907e-8,0,4.371138828673793e-8,1,0.000001370906943520822,0,0.022648807615041733,0.03556423261761665,-0.06753649562597275,1],[7,0.0000013716037301492179,4.371133144331907e-8,-1,0,4.371139183945161e-8,1,4.371139183945161e-8,0,1,-4.371144868287047e-8,0.0000013716037301492179,0,0.014564020559191704,-0.0007786036585457623,-0.06711816042661667,1],[7,-0.0038960769306868315,-0.00018511760572437197,0.9999924302101135,0,-0.04747150465846062,0.9988726377487183,-4.37110578843658e-8,0,-0.9988650679588318,-0.047471143305301666,-0.0039004720747470856,0,-0.051500532776117325,-0.006912448909133673,0.06736987829208374,1],[7,-0.07641041278839111,4.371138828673793e-8,-0.9970766305923462,0,3.3400651133774772e-9,1,4.3583600728425154e-8,0,0.9970766305923462,-6.01824430676752e-14,-0.07641041278839111,0,0.006668939255177975,-0.0007786020869389176,-0.08941607177257538,1],[7,-0.0038854111917316914,-0.00034243936534039676,0.9999924302101135,0,-0.08780550211668015,0.9961377382278442,-4.37110578843658e-8,0,-0.996130108833313,-0.08780483156442642,-0.0039004720747470856,0,-0.0669712945818901,-0.009627184830605984,0.06736987829208374,1],[7,0.08847923576831818,4.3711395392165286e-8,-0.9960780739784241,0,-3.867489883901953e-9,1,4.3539969851735805e-8,0,0.9960780739784241,-6.101884405737557e-14,0.08847923576831818,0,0.016914071515202522,-0.0007786039495840669,-0.044601503759622574,1],[7,0.0000013716037301492179,4.371133144331907e-8,-1,0,4.371139183945161e-8,1,4.371139183945161e-8,0,1,-4.371144868287047e-8,0.0000013716037301492179,0,-0.014287661761045456,-0.0007786024361848831,-0.06711815297603607,1],[7,-0.07641041278839111,4.371138828673793e-8,-0.9970766305923462,0,3.3400651133774772e-9,1,4.3583600728425154e-8,0,0.9970766305923462,-6.01824430676752e-14,-0.07641041278839111,0,-0.018198667094111443,-0.0007786020287312567,-0.08941607922315598,1],[7,0.08847923576831818,4.3711395392165286e-8,-0.9960780739784241,0,-3.867489883901953e-9,1,4.3539969851735805e-8,0,0.9960780739784241,-6.101884405737557e-14,0.08847923576831818,0,-0.008827637881040573,-0.000778603891376406,-0.04460150748491287,1],[7,0.3223544657230377,-0.0916680097579956,0.942170262336731,0,-0.498395174741745,-0.8626145124435425,0.08659343421459198,0,0.8047918677330017,-0.49748679995536804,-0.32375457882881165,0,0.09446685761213303,0.24517127871513367,0.19150592386722565,1],[7,0.27137818932533264,-0.19664506614208221,0.942170262336731,0,-0.7639675140380859,-0.6394180059432983,0.08659342676401138,0,0.5854123830795288,-0.7432870268821716,-0.32375451922416687,0,0.14383330941200256,0.2084914743900299,0.19150590896606445,1],[7,-0.28073257207870483,0.9174680709838867,0.2818540334701538,0,-0.9442408680915833,-0.31664764881134033,0.09024138003587723,0,0.17204198241233826,-0.24080440402030945,0.9552041292190552,0,0.12403222918510437,0.28176751732826233,-0.06136440485715866,1],[7,-0.2751193344593048,0.9290257096290588,0.24742791056632996,0,-0.9499455094337463,-0.30230793356895447,0.07882489264011383,0,0.14802975952625275,-0.21335677802562714,0.9656946659088135,0,0.13115912675857544,0.28045928478240967,-0.033736590296030045,1],[7,-0.5224653482437134,-0.22934965789318085,0.8212361335754395,0,-0.8294952511787415,-0.08626560866832733,-0.5518115162849426,0,0.19740217924118042,-0.9695138931274414,-0.14517363905906677,0,0.1265288144350052,0.03832430765032768,0.31496280431747437,1],[7,-0.07405124604701996,0.9565954804420471,0.28185391426086426,0,-0.9905513525009155,-0.10326879471540451,0.09024138748645782,0,0.11543119698762894,-0.27250832319259644,0.9552041292190552,0,0.1517685502767563,0.25481826066970825,-0.06136443838477135,1],[7,-0.30891433358192444,0.9275985360145569,0.21007868647575378,0,-0.9414753913879395,-0.32956621050834656,0.07078198343515396,0,0.13489209115505219,-0.17591840028762817,0.9751188158988953,0,0.12360799312591553,0.2838693857192993,-0.008615193888545036,1],[7,-0.08077358454465866,0.9655335545539856,0.24742813408374786,0,-0.9915376305580139,-0.10314872115850449,0.07882486283779144,0,0.10162992775440216,-0.23896734416484833,0.9656946063041687,0,0.15007564425468445,0.25530728697776794,-0.03373653069138527,1],[7,-0.0631498172879219,0.9756430387496948,0.2100786417722702,0,-0.994310736656189,-0.07959915697574615,0.07078199833631516,0,0.08578003942966461,-0.20441363751888275,0.9751188158988953,0,0.15829570591449738,0.2519221305847168,-0.008615207858383656,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[{"name":"default_btn_disabled","rect":{"x":0,"y":0,"width":40,"height":40},"offset":{"x":0,"y":0},"originalSize":{"width":40,"height":40},"rotated":false,"capInsets":[12,12,12,12],"vertices":{"rawPosition":[-20,-20,0,20,-20,0,-20,20,0,20,20,0],"indexes":[0,1,2,2,1,3],"uv":[0,40,40,40,0,0,40,0],"nuv":[0,0,1,0,0,1,1,1],"minPos":{"x":-20,"y":-20,"z":0},"maxPos":{"x":20,"y":20,"z":0}},"packable":true,"pixelsToUnit":100,"pivot":{"x":0.5,"y":0.5},"meshType":0}],[3],0,[0],[16],[41]],[[[10,".bin",463898161,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":1440,"length":156,"count":78,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":1440,"count":30,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.02580820955336094,2.3926541805267334,-1.0022352933883667],"maxPosition",8,[1,0.02225823700428009,3.001336097717285,-0.024929190054535866]]],-1],0,0,[],[],[]],[[[10,".bin",738135847,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":23232,"length":1920,"count":960,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":23232,"count":484,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5874064564704895,-0.8500004410743713,-0.5000003576278687],"maxPosition",8,[1,0.5874066352844238,1.1252166032791138,0.5000001192092896]]],-1],0,0,[],[],[]],[[[10,".bin",3893675988,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":7112,"length":888,"count":444,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":7112,"count":127,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-0.612135648727417,-4.2684123968683707e-7,-0.6367325782775879],"maxPosition",8,[1,0.612135648727417,2.9816811084747314,0.6367321610450745]]],-1],0,0,[],[],[]],[[[39,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,6],[42,5]],[[[46,"mat_map0_flag",[{"rasterizerState":{},"blendState":{"targets":[{}]},"depthStencilState":{}}],[{"USE_ALBEDO_MAP":true,"DCC_APP_NAME":1}],[[[{"albedoScale":1,"specularFactor":0,"shininessExponent":1.9999998807907104,"emissiveScale":0},"mainColor",8,[4,4291480266],"specularColor",8,[4,4294177779],"emissive",8,[4,4278190080],"mainTexture",6,0]],11]]],0,0,[0,0],[5,6],[43,44]],[[[10,".bin",3399562309,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":3456,"length":600,"count":300,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":3456,"count":72,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.047869447618722916,-6.7540666393028914e-9,-0.041456155478954315],"maxPosition",8,[1,0.04834306612610817,3.040665626525879,0.04145616665482521]]],-1],0,0,[],[],[]],[[[10,".bin",953558324,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":8512,"length":1152,"count":576,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8512,"count":133,"stride":64},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_color","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.5440863370895386,1.7526197382267128e-7,-0.5451859831809998],"maxPosition",8,[1,0.5421921014785767,1.0286537408828735,0.5285429358482361]]],-1],0,0,[],[],[]],[[[39,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_ALBEDO_MAP":true},{},{}],[[[{"metallic":0},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[5,6],[45,5]],[[[45,"builtin-standard",[{},{},{},{}],[{"hash":1034433180,"name":"builtin-standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"albedoOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"emissiveOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"normalOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias + vec2(anisotropyParam.z, 0.0);\n}\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    emissive = SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive * emissiveScaleParam.xyz;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, DEFAULT_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture(occlusionMap, DEFAULT_UV).r, pbrParams.x);\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 albedoOut;\n    layout(location = 1) out vec4 emissiveOut;\n    layout(location = 2) out vec4 normalOut;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      albedoOut = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      normalOut = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      emissiveOut = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        albedoOut = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n    uniform vec4 anisotropyParam;\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias + vec2(anisotropyParam.z, 0.0);\n}\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  uniform highp vec4 cc_reflectionProbeBlendData1;\n  uniform highp vec4 cc_reflectionProbeBlendData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 pbrParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleParam;\n    uniform vec4 anisotropyParam;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture2D(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture2D(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    emissive = SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive * emissiveScaleParam.xyz;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, DEFAULT_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture2D(occlusionMap, DEFAULT_UV).r, pbrParams.x);\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":97,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":127}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"FIX_ANISOTROPIC_ROTATION_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":2190396651,"name":"builtin-standard|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture2D(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":97,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":127}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"FIX_ANISOTROPIC_ROTATION_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]},{"hash":3071624841,"name":"builtin-standard|standard-vs|reflect-map-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias + vec2(anisotropyParam.z, 0.0);\n}\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    emissive = SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive * emissiveScaleParam.xyz;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, DEFAULT_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture(occlusionMap, DEFAULT_UV).r, pbrParams.x);\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n#endif\nlayout(location = 0) out vec4 fragColorX;\n#if CC_PIPELINE_TYPE == 1 && !CC_FORCE_FORWARD_SHADING\n  void main()  { fragColorX = vec4(0.0, 1.0, 0.0, 1.0); }\n#else\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n  #endif\n    #if !CC_FORWARD_ADD\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    fragColorX = packRGBE(color.rgb);\n  }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n    uniform vec4 anisotropyParam;\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias + vec2(anisotropyParam.z, 0.0);\n}\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  uniform highp vec4 cc_reflectionProbeBlendData1;\n  uniform highp vec4 cc_reflectionProbeBlendData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 pbrParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleParam;\n    uniform vec4 anisotropyParam;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n    baseColor.a *= FSInput_vertexColor.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  baseColor.rgb *= albedoScaleAndCutoff.xyz;\n  return baseColor;\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, emissiveScaleParam.w, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n  float anisotropyRotation = anisotropyParam.y * PI;\n  float anisotropyShape = anisotropyParam.x;\n  #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n    vec4 tex = texture2D(anisotropyMap, DEFAULT_UV);\n    anisotropyRotation = fract(anisotropyRotation * 0.5 + tex.y) * PI2;\n    anisotropyShape *= tex.x;\n  #endif\n  #if FIX_ANISOTROPIC_ROTATION_MAP\n    #if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n      vec4 reference = texture2D(anisotropyMapNearestFilter, DEFAULT_UV);\n      vec2 oneTap = vec2(0.0, 1.0 / anisotropyParam.w);\n      float threshold = 0.2;\n      vec4 sample1 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV + oneTap);\n      vec4 sample2 = texture2D(anisotropyMapNearestFilter, DEFAULT_UV - oneTap);\n      if (abs(sample1.y - reference.y) > threshold || abs(sample2.y - reference.y) > threshold) {\n          tex.y = reference.y;\n      }\n      anisotropyRotation = fract(anisotropyParam.y * PI * 0.5 + tex.y) * PI2;\n    #endif\n  #endif\n  isRotation = 1.0;\n  return vec4(anisotropyShape, anisotropyRotation, 0.0, 0.0);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    emissive = SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  return emissive * emissiveScaleParam.xyz;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, DEFAULT_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture2D(occlusionMap, DEFAULT_UV).r, pbrParams.x);\n  #endif\n  return pbr;\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n#endif\n#if CC_PIPELINE_TYPE == 1 && !CC_FORCE_FORWARD_SHADING\n  void main()  { gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); }\n#else\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n    #endif\n    #if !CC_FORWARD_ADD\n      float fogFactor = 1.0;\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n  #endif\n    #if !CC_FORWARD_ADD\n      CC_APPLY_FOG_BASE(color, fogFactor);\n    #endif\n    gl_FragColor = packRGBE(color.rgb);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":97,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":127}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"FIX_ANISOTROPIC_ROTATION_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"}]},{"hash":725306599,"name":"builtin-standard|planar-shadow-vs|planar-shadow-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1},{"name":"anisotropyParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_EMISSIVE_MAP"]},{"name":"anisotropyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]},{"name":"anisotropyMapNearestFilter","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["IS_ANISOTROPY","USE_ANISOTROPY_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + 0.001;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  vec3 view = normalize(cameraPos.xyz - shadowPos);\n  float viewLength = length(cameraPos.xyz - shadowPos);\n  shadowPos += view * min(1.0, 0.005 * viewLength);\n  return vec4(shadowPos, dist);\n}\nout highp float v_dist;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  vec4 shadowPos = CalculatePlanarShadowPos(In.worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  In.worldPos = shadowPos.xyz;\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_dist = shadowPos.w;\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n  vec4 anisotropyParam;\n};\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nin highp float v_dist;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  if(v_dist < 0.0)\n    discard;\n  fragColorX = cc_shadowColor;\n}"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_planarNDInfo;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + 0.001;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  vec3 view = normalize(cameraPos.xyz - shadowPos);\n  float viewLength = length(cameraPos.xyz - shadowPos);\n  shadowPos += view * min(1.0, 0.005 * viewLength);\n  return vec4(shadowPos, dist);\n}\nvarying highp float v_dist;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  vec4 shadowPos = CalculatePlanarShadowPos(In.worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  In.worldPos = shadowPos.xyz;\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_dist = shadowPos.w;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform lowp vec4 cc_shadowColor;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 albedo;\n    uniform vec4 albedoScaleAndCutoff;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if IS_ANISOTROPY && USE_ANISOTROPY_MAP\n  uniform sampler2D anisotropyMap;\n  uniform sampler2D anisotropyMapNearestFilter;\n#endif\n#if USE_ALPHA_TEST\n#endif\n#define CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n  #if USE_ALPHA_TEST\n    float alpha = albedo.ALPHA_TEST_CHANNEL;\n    #if USE_VERTEX_COLOR\n      alpha *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      alpha = texture2D(albedoMap, ALBEDO_UV).ALPHA_TEST_CHANNEL;\n    #endif\n    if (alpha < albedoScaleAndCutoff.w) discard;\n  #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvarying highp float v_dist;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  if(v_dist < 0.0)\n    discard;\n  gl_FragColor = cc_shadowColor;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":97,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":127}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"FIX_ANISOTROPIC_ROTATION_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DEFAULT_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ANISOTROPY_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]}]}],[{"name":"opaque","passes":[{"program":"builtin-standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[0],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.5],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"anisotropyIntensity":{"type":13,"value":[1],"handleInfo":["anisotropyParam",0,13]},"anisotropyRotation":{"type":13,"value":[0],"handleInfo":["anisotropyParam",1,13]},"anisotropyMapResolutionHeight":{"type":13,"value":[0],"handleInfo":["anisotropyParam",3,13]},"addOnShadowBias":{"type":13,"value":[0],"handleInfo":["anisotropyParam",2,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"anisotropyMap":{"value":"black","type":28},"anisotropyMapNearestFilter":{"value":"black","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[0,0.5,0,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"anisotropyParam":{"type":16,"value":[1,0,0,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"reflect-map","propertyIndex":0,"program":"builtin-standard|standard-vs|reflect-map-fs"},{"phase":"planar-shadow","propertyIndex":0,"program":"builtin-standard|planar-shadow-vs|planar-shadow-fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false,"stencilTestFront":true,"stencilFuncFront":5,"stencilPassOpFront":2,"stencilRefBack":128,"stencilRefFront":128,"stencilReadMaskBack":128,"stencilReadMaskFront":128,"stencilWriteMaskBack":128,"stencilWriteMaskFront":128}},{"pass":"gbuffer","phase":"gbuffer","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_PIPELINE_TYPE":1}}]},{"name":"transparent","passes":[{"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[0],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.5],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"anisotropyIntensity":{"type":13,"value":[1],"handleInfo":["anisotropyParam",0,13]},"anisotropyRotation":{"type":13,"value":[0],"handleInfo":["anisotropyParam",1,13]},"anisotropyMapResolutionHeight":{"type":13,"value":[0],"handleInfo":["anisotropyParam",3,13]},"addOnShadowBias":{"type":13,"value":[0],"handleInfo":["anisotropyParam",2,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"anisotropyMap":{"value":"black","type":28},"anisotropyMapNearestFilter":{"value":"black","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[0,0.5,0,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"anisotropyParam":{"type":16,"value":[1,0,0,0]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"builtin-standard|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"planar-shadow","propertyIndex":0,"program":"builtin-standard|planar-shadow-vs|planar-shadow-fs","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false,"stencilTestFront":true,"stencilFuncFront":5,"stencilPassOpFront":2,"stencilRefBack":128,"stencilRefFront":128,"stencilReadMaskBack":128,"stencilReadMaskFront":128,"stencilWriteMaskBack":128,"stencilWriteMaskFront":128}},{"phase":"deferred-forward","propertyIndex":0,"program":"builtin-standard|standard-vs|standard-fs","embeddedMacros":{"CC_PIPELINE_TYPE":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}}]}]]],0,0,[],[],[]],[[{"base":"2,2,0,0,2,0","rgbe":true,"mipmaps":[{"front":"d0MqyYBeFAkIi762QNy1/B@b47c0@e9a6d","back":"d0MqyYBeFAkIi762QNy1/B@b47c0@40c10","left":"d0MqyYBeFAkIi762QNy1/B@b47c0@8fd34","right":"d0MqyYBeFAkIi762QNy1/B@b47c0@74afd","top":"d0MqyYBeFAkIi762QNy1/B@b47c0@bb97f","bottom":"d0MqyYBeFAkIi762QNy1/B@b47c0@7d38f"}]}],[8],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[[96,"util/dcc/imported-specular-glossiness",[{"hash":688000055,"name":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"tags":[],"defines":[]},{"name":"albedoOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"tags":["CC_PIPELINE_TYPE"],"defines":["CC_PIPELINE_TYPE"]},{"name":"emissiveOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_PIPELINE_TYPE"]},{"name":"normalOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = texture(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        fragColorX = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    fragColorX = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    layout(location = 0) out vec4 albedoOut;\n    layout(location = 1) out vec4 emissiveOut;\n    layout(location = 2) out vec4 normalOut;\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      albedoOut = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      normalOut = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      emissiveOut = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        albedoOut = debugColor;\n      }\n    #endif\n    }\n#endif"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n    float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n        vec4 wPos = pos;\n        float cam_dis = distance(cameraPos, wPos.xyz);\n        return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n    }\n    float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * fogDensity);\n        return f;\n    }\n    float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n        vec4 wPos = pos;\n        float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n        float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n        return f;\n    }\n    float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n        vec4 wPos = pos;\n        vec3 camWorldProj = cameraPos.xyz;\n        camWorldProj.y = 0.;\n        vec3 worldPosProj = wPos.xyz;\n        worldPosProj.y = 0.;\n        float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n        float fDeltaY, fDensityIntegral;\n        if (cameraPos.y > fogTop) {\n            if (wPos.y < fogTop) {\n                fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n                fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n            }\n            else {\n                fDeltaY = 0.;\n                fDensityIntegral = 0.;\n            }\n        }\n        else {\n            if (wPos.y < fogTop) {\n                float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n                float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n                fDeltaY = abs(fDeltaA - fDeltaB);\n                fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n            }\n            else {\n                fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n                fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n            }\n        }\n        float fDensity;\n        if (fDeltaY != 0.) {\n            fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n        }\n        else {\n            fDensity = 0.;\n        }\n        float f = exp(-fDensity);\n        return f;\n    }\n  #endif\n  void CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n  {\n  #if CC_USE_FOG == 0\n  \tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n  #elif CC_USE_FOG == 1\n  \tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 2\n  \tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n  #elif CC_USE_FOG == 3\n  \tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n  #else\n  \tfactor = 1.0;\n  #endif\n  }\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\nvec3 SurfacesVertexModifyLocalNormal(in SurfacesStandardVertexIntermediate In)\n{\n  return In.normal.xyz;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 SurfacesVertexModifyLocalTangent(in SurfacesStandardVertexIntermediate In)\n    {\n      return In.tangent;\n    }\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\nvec3 SurfacesVertexModifyWorldNormal(in SurfacesStandardVertexIntermediate In)\n{\n    vec3 worldNormal = In.worldNormal.xyz;\n  #if CC_SURFACES_USE_TWO_SIDED\n      worldNormal.xyz *= In.worldNormal.w;\n  #endif\n  return worldNormal;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\nvec2 SurfacesVertexModifyShadowBias(in SurfacesStandardVertexIntermediate In, vec2 originShadowBias)\n{\n  return originShadowBias;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferFog(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(vec4(In.worldPos, 1.0), In.fogFactor);\n#endif\n}\nvoid CCSurfacesVertexTransferShadow(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId = vec4(0.0);\n  #endif\n  #if CC_RECEIVE_SHADOW\n    In.shadowBiasAndProbeId.xy = vec2(cc_shadowWHPBInfo.w, cc_shadowLPNNInfo.z);\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.xy += a_localShadowBiasAndProbeId.xy;\n    #else\n      In.shadowBiasAndProbeId.xy += cc_localShadowBias.xy;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      In.shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      In.shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n}\nvoid CCSurfacesVertexTransferLightMapUV(inout SurfacesStandardVertexIntermediate In)\n{\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #if USE_INSTANCING\n    In.lightmapUV.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    In.lightmapUV.z = a_lightingMapUVParam.w;\n  #else\n    In.lightmapUV.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    In.lightmapUV.z = cc_lightingMapUVParam.w;\n  #endif\n#endif\n}\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  In.normal.xyz = SurfacesVertexModifyLocalNormal(In);\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    In.tangent = SurfacesVertexModifyLocalTangent(In);\n  #endif\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matProj * cc_matView * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  vec3 viewDirect = normalize(cc_cameraPos.xyz - In.worldPos);\n  In.worldNormal.w = dot(In.worldNormal.xyz, viewDirect) < 0.0 ? -1.0 : 1.0;\n  In.worldNormal.xyz = SurfacesVertexModifyWorldNormal(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexTransferFog(In);\n  CCSurfacesVertexTransferLightMapUV(In);\n  CCSurfacesVertexTransferShadow(In);\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    In.shadowBiasAndProbeId.xy = SurfacesVertexModifyShadowBias(In, In.shadowBiasAndProbeId.xy);\n  #endif\n  CCSurfacesVertexOutput(In);\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform highp vec4 cc_time;\n  uniform mediump vec4 cc_probeInfo;\n  uniform mediump vec4 cc_debug_view_mode;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\nbool equalf_mode(float data1, float data2) { return abs(float(data1) - float(data2)) < 0.001; }\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 HDRToLDR(vec3 color)\n{\n  #if CC_USE_HDR\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING)\n    #endif\n    #if CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n  #endif\n  return color;\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nbool isnan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\nbool isinf(float x) {\n  return x == x * 2.0 && x != 0.0;\n}\nbool isnans(vec2 val) {\n    return isnan(val.x) || isnan(val.y);\n}\nbool isnans(vec3 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z);\n}\nbool isnans(vec4 val) {\n    return isnan(val.x) || isnan(val.y) || isnan(val.z) || isnan(val.w);\n}\nbool isinfs(vec2 val) {\n    return isinf(val.x) || isinf(val.y);\n}\nbool isinfs(vec3 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z);\n}\nbool isinfs(vec4 val) {\n    return isinf(val.x) || isinf(val.y) || isinf(val.z) || isinf(val.w);\n}\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 CalculateBinormal(vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    return cross(normal, tangent) * mirrorNormal;\n}\nvec3 CalculateNormal(vec3 tangent, vec3 binormal)\n{\n    return cross(tangent, binormal);\n}\nvec3 CalculateNormalFromTangentSpace(vec3 normalFromTangentSpace, float normalStrength, vec3 normal, vec3 tangent, float mirrorNormal)\n{\n    vec3 binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n    return (normalFromTangentSpace.x * normalStrength) * normalize(tangent) +\n           (normalFromTangentSpace.y * normalStrength) * normalize(binormal) +\n            normalFromTangentSpace.z * normalize(normal);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nvoid RotateTangentAndBinormal(inout vec3 tangent, inout vec3 binormal, vec3 normal, float rotationAngle)\n{\n    float cosTheta = cos(rotationAngle), sinTheta = sin(rotationAngle);\n    vec3 B = RotationVecFromAxisY(vec3(1.0, 0.0, 0.0), cosTheta, sinTheta);\n    vec3 T = RotationVecFromAxisY(vec3(0.0, 0.0, 1.0), cosTheta, sinTheta);\n    vec3 tangentNew, binormalNew;\n    binormalNew = B.x * binormal + B.y * normal + B.z * tangent;\n    binormal = normalize(binormalNew);\n    tangentNew = T.x * binormal + T.y * normal + T.z * tangent;\n    tangent = normalize(tangentNew);\n}\nvoid RotateNormalAndBinormal(inout vec3 binormal, inout vec3 normal, in vec3 tangent, float rotationAngle, float mirrorNormal)\n{\n  if(rotationAngle > 0.0)\n  {\n    normal += (binormal - normal) * rotationAngle;\n    normal = normalize(normal);\n    binormal = CalculateBinormal(normal, tangent, mirrorNormal);\n  }\n  else if(rotationAngle < 0.0)\n  {\n    binormal += (binormal - normal) * rotationAngle;\n    binormal = normalize(binormal);\n    normal = CalculateNormal(tangent, binormal);\n  }\n}\nvec2 signNotZero(vec2 v) {\n  return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\nvec2 float32x3_to_oct(in vec3 v) {\n  vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n  return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\nbool GetMetallicAlbedoFromDiffuseSpecularWithoutColor(out float metallic, out vec3 albedo, vec3 diffuse, vec3 specular, float f0 )\n{\n\tfloat d = max(max(diffuse.x, diffuse.y), diffuse.z);\n\tvec3 normalizedColor = diffuse / (d + (d < EPSILON_LOWP ? EPSILON_LOWP : 0.0));\n\tnormalizedColor = d < EPSILON_LOWP ? specular : normalizedColor;\n\tfloat s = max(max(specular.x, specular.y), specular.z);\n\tfloat delta = (d + s) * (d + s)  - 4.0 * f0 * d;\n\tfloat deltaSqrt = sqrt(max(0.0, delta));\n\tfloat solverMetallic = (-d - s + 2.0 * f0 + deltaSqrt) / (2.0 * f0);\n\tvec3 solverAlbedo = (d + s) * normalizedColor - vec3(f0 * (1.0 - solverMetallic));\n\tbool isValidSolver = delta >= 0.0;\n\tmetallic = isValidSolver ? clamp(solverMetallic, 0.0, 1.0) : 0.0;\n\talbedo = isValidSolver ? vec3(max(0.0, solverAlbedo.x), max(0.0, solverAlbedo.y), max(0.0, solverAlbedo.z)) : diffuse;\n\treturn isValidSolver;\n}\nfloat RoughnessToPerceptualRoughness(float roughness)\n{\n  return sqrt(roughness);\n}\n  vec3 EnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity) {\n    #if CC_USE_IBL\n      #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n        roughness = RoughnessToPerceptualRoughness(roughness);\n      #endif\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    \tvec4 biased = fragTextureLod(cc_environment, rotationDir, mip + mipBias);\n     \tvec4 filtered = textureCube(cc_environment, rotationDir);\n      #if CC_USE_IBL == 2\n      \tbiased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n  vec3 EnvReflection(samplerCube tex, vec3 R, float roughness, float mipCount) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    #if CC_USE_IBL == 2\n      return unpackRGBE(envmap);\n    #else\n      return SRGBToLinear(envmap.rgb);\n    #endif\n  }\n  vec3 EnvReflectionOfReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    #if !CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING && !CC_IBL_CONVOLUTED\n      roughness = RoughnessToPerceptualRoughness(roughness);\n    #endif\n    vec3 rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n    vec4 envmap = fragTextureLod(tex, rotationDir, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  float SampleShadowMap (vec3 shadowNDCPos, highp sampler2D shadowMap)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n    #else\n      return texture2D(shadowMap, shadowNDCPos.xy).x;\n    #endif\n  }\n  float SampleShadowMapSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block1 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos.y, shadowNDCPos.z), shadowMap);\n    float block2 = SampleShadowMap(vec3(shadowNDCPos.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float block3 = SampleShadowMap(vec3(shadowNDCPos_offset.x, shadowNDCPos_offset.y, shadowNDCPos.z), shadowMap);\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(texture2D(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, texture2D(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(texture2D(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, texture2D(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, texture2D(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, texture2D(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, texture2D(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, texture2D(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, texture2D(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, texture2D(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, texture2D(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, texture2D(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, texture2D(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, texture2D(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, texture2D(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, texture2D(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, texture2D(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, texture2D(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, texture2D(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, texture2D(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, texture2D(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, texture2D(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, texture2D(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, texture2D(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, texture2D(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, texture2D(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, texture2D(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, texture2D(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  uniform highp vec4 cc_reflectionProbeBlendData1;\n  uniform highp vec4 cc_reflectionProbeBlendData2;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n  bool isBlendReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeBlendData2.w > 1000.0;\n    #endif\n  }\n  void GetBlendCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeBlendData1.xyz;\n        boxHalfSize = cc_reflectionProbeBlendData2.xyz;\n        mipCount = cc_reflectionProbeBlendData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n  void GetLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  \tvec4 lightmap;\n  \tvec2 occlusion;\n  \tSampleAndDecodeLightMapColor(lightmapColor, dirShadow, ao, lightingMap, luv, lum, worldNormal);\n  #if CC_USE_HDR\n      lightmapColor.rgb *= cc_exposure.w * cc_exposure.x;\n  #endif\n  }\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 specularColor;\n    uniform vec4 emissive;\n    uniform float emissiveScale;\n    uniform float alphaThreshold;\n    uniform float shininessExponent;\n    uniform float glossiness;\n    uniform float metallic;\n    uniform float normalScale;\n    uniform float transparencyFactor;\n    uniform float diffuseFactor;\n    uniform float specularFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\nfloat discolor(vec3 srcColor)\n{\n  return dot(GRAY_VECTOR, srcColor);\n}\nfloat convertShininessExponent(float shininessExp)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float glossiness = clamp(sqrt(shininessExp) * 0.1, 0.0, 0.95);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float l2 = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n    float glossiness = pow(l2, 0.5);\n  #else\n    float glossiness = clamp(log(shininessExp + EPSILON) * 0.1442695 , 0.0, 1.0);\n  #endif\n    return glossiness;\n}\nfloat getSpecularIntensityFromRoughness(float roughness)\n{\n  #if DCC_APP_NAME == DCC_APP_BLENDER\n    float specularIntensityMultiplier = mix(1.0, 5.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_CINEMA4D\n    float specularIntensityMultiplier = mix(1.0, 50.0, roughness);\n  #elif DCC_APP_NAME == DCC_APP_MAX || DCC_APP_NAME == DCC_APP_MAYA\n    float specularIntensityMultiplier = mix(1.0, 20.0, roughness);\n  #else\n    float specularIntensityMultiplier = 1.0;\n  #endif\n    return specularIntensityMultiplier;\n}\nvec4 getSpecularColorAndFactor()\n{\n  vec3 inSpecular = specularColor.rgb * specularFactor;\n  float inFactor = 1.0;\n  #if USE_SPECULAR_GLOSSINESS_MAP\n    inSpecular = SRGBToLinear(texture2D(specularGlossinessMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_SPECULAR_MAP\n      vec4 specularTex = texture2D(specularMap, TEXTURE_UV);\n      specularTex.rgb = SRGBToLinear(specularTex.rgb);\n      inSpecular = specularTex.rgb;\n  #endif\n  return vec4(inSpecular, inFactor);\n}\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n  vec3 normal = FSInput_worldNormal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    normal = CalculateNormalFromTangentSpace(nmmp, normalScale, normalize(normal.xyz), normalize(FSInput_worldTangent), FSInput_mirrorNormal);\n  #endif\n  return normalize(normal);\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n  vec3 emissiveColor = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n      emissiveColor.rgb = SRGBToLinear(texture2D(emissiveMap, TEXTURE_UV).rgb);\n  #endif\n  #if USE_EMISSIVESCALE_MAP\n      vec4 emissiveScaleColor = texture2D(emissiveScaleMap, TEXTURE_UV);\n      emissiveScaleColor.rgb = SRGBToLinear(emissiveScaleColor.rgb);\n      emissiveColor.rgb *= emissiveScaleColor.rgb;\n  #else\n      emissiveColor.rgb *= emissiveScale;\n  #endif\n  return emissiveColor;\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n    vec4 baseColor = vec4(1.0);\n    #if USE_VERTEX_COLOR\n      baseColor.rgb *= SRGBToLinear(FSInput_vertexColor.rgb);\n      baseColor.a *= FSInput_vertexColor.a;\n    #endif\n    #if USE_ALBEDO_MAP\n      vec4 texColor = texture2D(albedoMap, TEXTURE_UV);\n      texColor.rgb = SRGBToLinear(texColor.rgb);\n      texColor.a *= transparencyFactor;\n      baseColor *= texColor;\n    #else\n      baseColor *= diffuseColor;\n    #endif\n    baseColor.rgb *= diffuseFactor;\n    #if USE_TRANSPARENCY_MAP\n      baseColor.a = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n      #if DCC_APP_NAME == DCC_APP_MAYA\n        baseColor.a = 1.0 - baseColor.a;\n      #endif\n    #endif\n    #if USE_ALPHA_TEST\n      if (baseColor.a < alphaThreshold) discard;\n    #endif\n    vec4 specularColorAndFactor = getSpecularColorAndFactor();\n    float inGlossiness = 0.0, inSpecularIntensity = 1.0;\n    #if HAS_EXPORTED_GLOSSINESS\n      #if USE_SPECULAR_GLOSSINESS_MAP\n        inGlossiness = 1.0 - texture2D(specularGlossinessMap, TEXTURE_UV).a;\n      #else\n        inGlossiness = glossiness;\n      #endif\n    #else\n      #if USE_SHININESS_MAP\n        #if GLOSSINESS_MAP_USE_SINGLE_CHANNEL\n          inGlossiness = 1.0 - texture2D(shininessExponentMap, TEXTURE_UV).GLOSSINESS_MAP_CHANNEL;\n        #else\n          inGlossiness = 1.0 - discolor(texture2D(shininessExponentMap, TEXTURE_UV).rgb);\n        #endif\n      #else\n        inGlossiness = convertShininessExponent(shininessExponent);\n      #endif\n      inSpecularIntensity *= getSpecularIntensityFromRoughness(1.0 - inGlossiness);\n    #endif\n    float inMetallic = 0.0;\n    vec3 albedo = baseColor.rgb;\n    #if HAS_EXPORTED_METALLIC\n      inMetallic = metallic;\n      float spec = specularFactor;\n      #if USE_SPECULAR_MAP\n        spec = dot(GRAY_VECTOR, texture2D(specularMap, TEXTURE_UV).rgb);\n      #endif\n      inSpecularIntensity *= spec * 0.5;\n    #else\n      GetMetallicAlbedoFromDiffuseSpecularWithoutColor(inMetallic, albedo.rgb, baseColor.rgb, specularColorAndFactor.rgb, 0.04);\n      inSpecularIntensity *= inMetallic;\n    #endif\n    baseColor.rgb = albedo;\n    surfaceData.baseColor = baseColor;\n    surfaceData.specularIntensity = inSpecularIntensity * 0.5;\n    surfaceData.roughness = 1.0 - inGlossiness;\n    surfaceData.metallic = inMetallic;\n    surfaceData.ao = 1.0;\n    #if USE_OCCLUSION_MAP\n      surfaceData.ao = texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n    #endif\n}\nstruct LightingIntermediateData\n{\n  vec3 N, H, L, V;\n  float distToLight, distToLightSqr;\n  float distToCamera, distToCameraSqr;\n  float angleAttenuation, distAttenuation;\n  float NoL, NoV, NoH;\n  float NoLSat, NoVSat, NoHSat;\n  float NoVAbsSat;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPosition, worldPosition_fract_part;\n  #else\n  vec3 worldPosition;\n  #endif\n  vec3 T, B;\n  float specularParam;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 shadowPosAndDepth;\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitScatteringParams;\n  vec3 outScatteringColor, inScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n};\nvoid CCSurfacesLightingGetIntermediateData_PerPixel(inout LightingIntermediateData data, vec3 worldNormal, vec3 worldPos, vec3 worldTangent, vec3 worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n    , float anisotropyShape\n#endif\n)\n{\n  data.N = worldNormal;\n  data.V = cc_cameraPos.xyz - worldPos;\n  data.distToCameraSqr = dot(data.V, data.V);\n  data.distToCamera = sqrt(data.distToCameraSqr);\n  data.V /= data.distToCamera;\n  data.angleAttenuation = data.distAttenuation = 1.0;\n  data.NoV = dot(data.N, data.V);\n  data.NoVSat = max(data.NoV, 0.0);\n  data.NoVAbsSat = max(abs(data.NoV), 0.0);\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(data.worldPosition, data.worldPosition_fract_part, worldPos);\n  #else\n  data.worldPosition = worldPos;\n  #endif\n  data.T = worldTangent;\n  data.B = worldBinormal;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  data.anisotropyShape = anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.outScatteringColor = vec3(1.0);\n  data.inScatteringColor = vec3(0.0);\n  data.transmitScatteringParams = vec4(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  data.shadowPosAndDepth = vec4(0.0, 0.0, SURFACES_MAX_TRANSMIT_DEPTH_VALUE, SURFACES_MAX_TRANSMIT_DEPTH_VALUE);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  data.baseColorTT = vec3(0.0);\n  data.ttIntensity = data.ttScatterCoef = 0.0;\n#endif\n}\nvoid CCSurfacesLightingGetIntermediateData_PerLight(inout LightingIntermediateData data, vec3 lightDirWithDist)\n{\n  data.L = lightDirWithDist;\n  data.distToLightSqr = dot(data.L, data.L);\n  data.distToLight = sqrt(data.distToLightSqr);\n  data.L /= data.distToLight;\n  data.H = normalize(data.L + data.V);\n  data.NoL = dot(data.N, data.L);\n  data.NoH = dot(data.N, data.H);\n  data.NoLSat = max(data.NoL, 0.0);\n  data.NoHSat = max(data.NoH, 0.0);\n}\nstruct LightingResult\n{\n  vec3 diffuseColorWithLighting, specularColorWithLighting, specularColorWithEnvLighting;\n  vec3 directDiffuse, directSpecular;\n  vec3 environmentDiffuse, environmentSpecular;\n  float shadow, ao;\n  vec3 lightmapColor;\n  vec3 emissive;\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float fresnel;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  vec3 directTransmitSpecular, environmentTransmitSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 directTransmitDiffuse, environmentTransmitDiffuse;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 direct2ndSpecular, environment2ndSpecular;\n  vec3 specularColorWithLighting2ndSpecular, specularColorWithEnvLighting2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 directTT;\n  vec3 diffuseColorWithLightingTT;\n#endif\n};\nstruct LightingMiscData\n{\n  float lightType;\n  vec3 lightPos, lightDir;\n  vec4 lightColorAndIntensity;\n  vec4 lightSizeRangeAngle;\n};\nfloat D_GGX(float roughness, float NoH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NoH * m2 - NoH) * NoH + 1.0;\n    return m2 / max(EPSILON, d * d);\n}\nfloat D_GGXMobile(float roughness, float NoH) {\n  float OneMinusNoHSqr = 1.0 - NoH * NoH;\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nvoid GetAnisotropicRoughness(float roughness, float anisotropyShape, out float roughnessX, out float roughnessY)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    float r1 = roughness, r2 = roughness;\n    float lerpedRoughness = mix(1.0, 10.0, anisotropyShape);\n    r2 *= shapeSign < 0.0 ? lerpedRoughness : 1.0;\n    r1 *= shapeSign > 0.0 ? lerpedRoughness : 1.0;\n    roughnessX = saturate(r1);\n    roughnessY = saturate(r2);\n}\nfloat D_GGXAniso(float RoughnessX, float RoughnessY, float NoH, vec3 H, vec3 X, vec3 Y)\n{\n    float mx = max(EPSILON_LOWP, RoughnessX * RoughnessX);\n    float my = max(EPSILON_LOWP, RoughnessY * RoughnessY);\n    float XoH = dot(X, H);\n    float YoH = dot(Y, H);\n    float d = XoH * XoH / (mx * mx) + YoH * YoH / (my * my) + NoH * NoH;\n    return 1.0 / max(EPSILON_LOWP, mx * my * d * d);\n}\nvec3 GetAnisotropicReflect(float roughness, float anisotropyShape, vec3 V, vec3 N, vec3 X, vec3 Y)\n{\n    float shapeSign = sign(anisotropyShape);\n    anisotropyShape *= anisotropyShape;\n    anisotropyShape = min(anisotropyShape, 0.4);\n    anisotropyShape *= smoothstep(0.0, 0.03, roughness);\n    vec3 reflectTarget = shapeSign < 0.0 ? mix(N, -Y, anisotropyShape) :\n                         shapeSign > 0.0 ? mix(N, -X, anisotropyShape) : N;\n    return reflect(-V, reflectTarget);\n}\nvec3 IntegratedGFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#define DiffuseCoefficient_EnergyConservation INV_PI\nfloat CalculateFresnelCoefficient(float ior, float NoVSat)\n{\n\tfloat g, c, n, prev, next;\n\tn = ior;\n\tc = ior * NoVSat;\n\tg = sqrt(1.0 + c * c - c);\n\tprev = (g - c) / (g + c);\n\tnext = (c * (g+c) - n*n) / (c * (g-c) + n*n);\n\tprev *= prev;\n\tnext *= next;\n\treturn 0.5 * prev * (1.0 + next);\n}\nvec3 CalculateScattering(vec3 unscatteredColor, float distance, float outScatterExtinctCoef, float inScatterExtinctCoef, float inScatterCoef, vec3 inScatterColor, vec3 outScatterColor)\n{\n    vec2 e = vec2(outScatterExtinctCoef, inScatterExtinctCoef * inScatterCoef);\n    vec2 extinction = exp(-e * distance);\n    vec3 inScattered = (1.0 - extinction.y) * inScatterColor;\n\tvec3 outScattered = unscatteredColor * extinction.x * outScatterColor;\n    return outScattered + inScattered;\n}\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n  vec3 v = vec3(0.0);\n  vec3 up = cross(right, lookAt);\n  worldPos -= lightPos;\n  v.x = dot(worldPos, right);\n  v.y = dot(worldPos, up);\n  v.z = dot(worldPos, lookAt);\n  vec3 result = step(abs(v), BoundingHalfSizeVS);\n  return result.x * result.y * result.z;\n}\nfloat CalculateDistanceAttenuation(float distToLightSqr, float lightRadius, float lightRange, float lightType)\n{\n  float attRadiusSqrInv = 1.0 / max(lightRange, 0.01);\n  attRadiusSqrInv *= attRadiusSqrInv;\n  float litRadiusSqr = lightRadius * lightRadius;\n  float edgeAttenuation = (IS_POINT_LIGHT(lightType) || IS_RANGED_DIRECTIONAL_LIGHT(lightType)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distToLightSqr);\n  return GetDistAtt(distToLightSqr, attRadiusSqrInv) * edgeAttenuation;\n}\nfloat CalculateAngleAttenuation(vec3 spotLightDir, vec3 L, float cosAngleOuter)\n{\n  float cosInner = max(dot(spotLightDir, L), 0.01);\n  float litAngleScale = 1.0 / max(0.001, cosInner - cosAngleOuter);\n  float litAngleOffset = -cosAngleOuter * litAngleScale;\n  return GetAngleAtt(L, spotLightDir, litAngleScale, litAngleOffset);\n}\nvec3 CalculateRefractDirection(vec3 N, vec3 V, float NoV, float ior)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  float cosA = abs(NoV);\n  float sinA = sqrt(1.0 - cosA * cosA);\n  float sinB = saturate(sinA / ior);\n  float cosB = sqrt(1.0 - sinB * sinB);\n  vec3 edgeA = -V + N * cosA;\n  vec3 edgeB = normalize(edgeA) * sinB;\n  vec3 R = edgeB - N * cosB;\n  return R;\n}\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\nvec3 CalculateDirectDiffuse(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    return irradiance * DiffuseCoefficient_EnergyConservation;\n}\nvec3 CalculateDirectSpecular(in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n    vec3 irradiance = vec3(lightingData.NoLSat) * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    float roughness = lightingData.specularParam;\n  #if CC_SURFACES_LIGHTING_ANISOTROPIC\n      float rT, rB;\n      GetAnisotropicRoughness(roughness, lightingData.anisotropyShape, rT, rB);\n      float calcSpec = D_GGXAniso(rT, rB, lightingData.NoHSat, lightingData.H, lightingData.T, lightingData.B);\n  #else\n    #if CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n      float calcSpec = (roughness * 0.25 + 0.25) * D_GGXMobile(roughness, lightingData.NoHSat);\n    #else\n      float calcSpec = D_GGX(roughness, lightingData.NoHSat);\n    #endif\n  #endif\n    return irradiance * calcSpec;\n}\n#if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  vec3 EnvAnisotropicReflection(samplerCube tex, vec3 R, float roughness, float mipCount, float anisotropyShape, vec3 V, vec3 N, vec3 T, vec3 B) {\n      R = normalize(R);\n      float integratedBRDF = 0.0;\n      vec3 envSpec = vec3(0.0);\n      const int SAMPLE_STEP_COUNT = CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT;\n      float sampleAngleRange = PI * abs(anisotropyShape);\n      vec3 anisoDirection = anisotropyShape < 0.0 ? T : B;\n      vec3 ROnNormalPlane = normalize(R - anisoDirection * dot(R, anisoDirection));\n      vec3 stepOffset = normalize(ROnNormalPlane - N) * (sampleAngleRange / float(SAMPLE_STEP_COUNT * 2));\n      for (int i = -SAMPLE_STEP_COUNT; i <= SAMPLE_STEP_COUNT; ++i)\n      {\n          float rT, rB;\n          GetAnisotropicRoughness(roughness, anisotropyShape, rT, rB);\n          #if CC_IBL_CONVOLUTED\n            float coef = abs(float(i)) / float(SAMPLE_STEP_COUNT) * float(SAMPLE_STEP_COUNT);\n          #else\n            float coef = pow(abs(float(i)) / float(SAMPLE_STEP_COUNT), 1.3) * float(SAMPLE_STEP_COUNT);\n          #endif\n          vec3 H = normalize(N + stepOffset * sign(float(i)) * coef);\n          vec3 L = reflect(-V, H);\n          float NoHSat = saturate(dot(N, H));\n          float calcSpec = D_GGXAniso(rT, rB, NoHSat, H, T, B);\n          envSpec += calcSpec * EnvReflection(tex, L, roughness, mipCount);\n          integratedBRDF += calcSpec;\n      }\n      envSpec /= integratedBRDF;\n      return envSpec;\n  }\n#endif\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, R, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflection(tex, R, roughness, mipCount);\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 SampleEnvironmentSpecular(samplerCube tex, in LightingIntermediateData lightingData, float mipCount, vec3 worldPos, vec3 cubeCenterPos, vec3 boxHalfSize, bool isRGBE)\n{\n    vec3 envSpec = vec3(0.0);\n    float roughness = lightingData.specularParam;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && !CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      vec3 R = GetAnisotropicReflect(roughness, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n    #else\n      vec3 R = CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV);\n    #endif\n    vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, cubeCenterPos, boxHalfSize);\n    R = fixedR.xyz;\n    vec3 envmap = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).xyz * cc_ambientSky.w;\n    #if CC_SURFACES_LIGHTING_ANISOTROPIC && CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n      envSpec = EnvAnisotropicReflection(tex, fixedR.xyz, roughness, mipCount, lightingData.anisotropyShape, lightingData.V, lightingData.N, lightingData.T, lightingData.B);\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        envSpec = mix(envmap, envSpec, fixedR.w);\n      #endif\n    #else\n      #if CC_SURFACES_USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        envSpec = EnvReflectionWithMipFiltering(normalize(R), roughness, mipCount, 0.6);\n      #else\n        envSpec = EnvReflectionOfReflectionProbe(tex, R, roughness, mipCount, isRGBE);\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n          envSpec = mix(envmap, envSpec, fixedR.w);\n        #endif\n      #endif\n    #endif\n    return envSpec;\n}\nvec3 CalculateEnvironmentDiffuse(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  float fAmb = max(EPSILON, 0.5 - lightingData.N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      vec3 rotationDir = RotationVecFromAxisY(lightingData.N, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n  #endif\n  ambDiff.rgb *= lightIntensity;\n  #if CC_USE_LIGHT_PROBE\n    ambDiff.rgb += SHEvaluate(lightingData.N);\n  #endif\n  return ambDiff.rgb;\n}\nvec3 CalculateEnvironmentSpecular(in LightingIntermediateData lightingData, float lightIntensity)\n{\n  vec3 envSpec = vec3(0.0);\n#if CC_USE_REFLECTION_PROBE\n    vec3 worldPos;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    worldPos = unpackHighpData(lightingData.worldPosition, lightingData.worldPosition_fract_part);\n    #else\n    worldPos = lightingData.worldPosition;\n    #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n    vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n    if(FSInput_reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPos, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0)).xyz;\n    }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, FSInput_reflectionProbeId);\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(lightingData.N, lightingData.V, worldPos, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, lightingData.V, R);\n        envSpec = unpackRGBE(fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount)).xyz;\n    }\n  #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    if(FSInput_reflectionProbeId < 0.0){\n        envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n    }else{\n      vec3 centerPos, boxHalfSize;\n      float mipCount;\n      GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, FSInput_reflectionProbeId);\n      envSpec = SampleEnvironmentSpecular(cc_reflectionProbeCubemap, lightingData, mipCount, worldPos, centerPos, boxHalfSize, isReflectProbeUsingRGBE(FSInput_reflectionProbeId));\n      float blendFactor = 0.0;\n      #if USE_INSTANCING\n        blendFactor = FSInput_reflectionProbeData.x;\n      #else\n        blendFactor = cc_reflectionProbeBlendData1.w;\n      #endif\n      if(FSInput_reflectionProbeBlendId < 0.0)\n      {\n        vec3 skyBoxEnv = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w).rgb * lightIntensity;\n        #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n          envSpec = mix(envSpec, skyBoxEnv, blendFactor);\n        #else\n          vec3 R = normalize(CalculateReflectDirection(lightingData.N, lightingData.V, lightingData.NoV));\n          vec4 fixedR = CalculateBoxProjectedDirection(R, worldPos, centerPos, boxHalfSize);\n          envSpec = mix(skyBoxEnv, envSpec, fixedR.w);\n        #endif\n      }else{\n        vec3 centerPosBlend, boxHalfSizeBlend;\n        float mipCountBlend;\n        GetBlendCubeReflectionProbeData(centerPosBlend, boxHalfSizeBlend, mipCountBlend, FSInput_reflectionProbeBlendId);\n        vec3 probeBlend = SampleEnvironmentSpecular(cc_reflectionProbeBlendCubemap, lightingData, mipCountBlend, worldPos, centerPosBlend, boxHalfSizeBlend, isBlendReflectProbeUsingRGBE(FSInput_reflectionProbeBlendId));\n        envSpec = mix(envSpec, probeBlend, blendFactor);\n      }\n    }\n  #endif\n#elif CC_USE_IBL\n    envSpec = SampleEnvironmentSpecular(cc_environment, lightingData, cc_ambientGround.w);\n#endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = FSInput_reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  return envSpec * lightIntensity;\n}\nbool CCSurfacesLightingEnableShadow(in float NoL)\n{\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  return true;\n#elif CC_SURFACES_LIGHTING_SSS\n  return true;\n#else\n  return NoL > 0.0;\n#endif\n}\nfloat CCSurfacesLightingCalculateDistanceAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in float lightType)\n{\n  return CalculateDistanceAttenuation(lightingData.distToLightSqr, lightSizeRangeAngle.x, lightSizeRangeAngle.y, lightType);\n}\nfloat CCSurfacesLightingCalculateAngleAttenuation(in LightingIntermediateData lightingData, in vec4 lightSizeRangeAngle, in vec3 spotLightDir)\n{\n  return CalculateAngleAttenuation(spotLightDir, lightingData.L, lightSizeRangeAngle.z);\n}\nvoid CCSurfacesLightingCalculateDirect(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateDirectSpecular(lightingData, lightSourceColorAndIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\nvoid CCSurfacesLightingCalculateEnvironment(out vec3 lightingDiffuse, out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n{\n#if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n  lightingDiffuse = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n#else\n  lightingDiffuse = vec3(0.0);\n#endif\n#if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n  lightingSpecular = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n#else\n  lightingSpecular = vec3(0.0);\n#endif\n}\n#if CC_SURFACES_LIGHTING_USE_FRESNEL\n  float CCSurfaceLightingCalculateFresnel(in LightingIntermediateData lightingData)\n  {\n    return CalculateFresnelCoefficient(lightingData.ior, abs(lightingData.NoV));\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  void CCSurfacesLightingCalculateDirectTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    float roughness = lightingData.specularParam;\n    float NoLSat = saturate(dot(lightingData.N, -lightingData.L));\n    vec3 irradiance = NoLSat * lightSourceColorAndIntensity.rgb * lightSourceColorAndIntensity.w;\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float RoL = dot(lightingData.L, normalize(R));\n    float calcSpec = D_GGX(roughness, saturate(RoL));\n    lightingSpecular = irradiance * calcSpec;\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitSpecular(out vec3 lightingSpecular, in LightingIntermediateData lightingData, float lightIntensity)\n  {\n    vec3 envSpec = vec3(0.0);\n    vec3 R = CalculateRefractDirection(lightingData.N, lightingData.V, lightingData.NoV, lightingData.ior);\n    float roughness = lightingData.specularParam;\n  #if CC_USE_REFLECTION_PROBE\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      envSpec = EnvReflection(cc_reflectionProbeCubemap, R, roughness, cc_ambientGround.w);\n    #endif\n  #endif\n  #if CC_USE_IBL && CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_CUBE\n    envSpec = EnvReflection(cc_environment, R, roughness, cc_ambientGround.w);\n  #endif\n    lightingSpecular = CalculateScattering(envSpec * lightIntensity, lightingData.transmitScatteringParams.w, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define objectThickness lightingData.transmitDiffuseParams.x\n  #define transmitMask lightingData.transmitDiffuseParams.y\n  #define envTransmitScale lightingData.transmitDiffuseParams.z\n  #define envFixedDistanceScale lightingData.transmitScatteringParams.w\n  #define transmitDistanceScale lightingData.transmitDiffuseParams.w\n  #define DONOT_USE_SHADOWMAP_DISTANCE ((abs(float(lightingData.shadowPosAndDepth.z) - float(lightingData.shadowPosAndDepth.w)) < EPSILON) && (abs(float(lightingData.shadowPosAndDepth.z) - float(SURFACES_MAX_TRANSMIT_DEPTH_VALUE)) < EPSILON))\n  #define SHADOWMAP_DISTANCE max(lightingData.shadowPosAndDepth.w - lightingData.shadowPosAndDepth.z, 0.0)\n  void CCSurfacesLightingCalculateDirectTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float shadow)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      distance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      shadow = step(SHADOWMAP_DISTANCE, objectThickness) > 0.0 ? 1.0 : shadow;\n    }\n    vec3 backIrradiance = CalculateDirectDiffuse(lightingData, lightSourceColorAndIntensity);\n    backIrradiance *= shadow * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(out vec3 transmitDiffuse, in LightingIntermediateData lightingData, float lightIntensity, float ao, vec3 shadowLightDirection)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n    float distance = lightingData.transmitScatteringParams.w;\n    if (!DONOT_USE_SHADOWMAP_DISTANCE)\n    {\n      float shadowMapDistance = transmitDistanceScale * SHADOWMAP_DISTANCE;\n      float fixedDistance = transmitDistanceScale * envFixedDistanceScale;\n      float lerpCoef = saturate(dot(lightingData.N, shadowLightDirection));\n      distance = mix(fixedDistance, shadowMapDistance, lerpCoef);\n    }\n    vec3 backIrradiance = CalculateEnvironmentDiffuse(lightingData, lightIntensity);\n    backIrradiance *= ao * transmitMask;\n    transmitDiffuse = CalculateScattering(backIrradiance, distance, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.x, lightingData.transmitScatteringParams.y, lightingData.inScatteringColor.rgb, lightingData.outScatteringColor.rgb);\n    transmitDiffuse *= envTransmitScale;\n  #else\n    transmitDiffuse = vec3(0.0);\n  #endif\n  }\n  #undef objectThickness\n  #undef transmitMask\n  #undef envTransmitScale\n  #undef envFixedDistanceScale\n  #undef DONOT_USE_SHADOWMAP_DISTANCE\n  #undef SHADOWMAP_DISTANCE\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #ifndef CC_SURFACES_FRAGMENT_MODIFY_2ND_SPECULAR_COLOR\n  #endif\n  void CCSurfacesLightingCalculateDirect2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    CCSurfacesLightingCalculateDirect(unused, specularLighting, lightingData, lightSourceColorAndIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n  void CCSurfacesLightingCalculateEnvironment2ndSpecular(out vec3 specularLighting, in LightingIntermediateData lightingData, float lightIntensity, float intensitySpecular, in vec3 originalSpecular)\n  {\n  #if !CC_SURFACES_LIGHTING_DISABLE_SPECULAR\n    vec3 unused;\n    specularLighting = CalculateEnvironmentSpecular(lightingData, lightIntensity);\n    specularLighting *= intensitySpecular;\n  #else\n    specularLighting = vec3(0.0);\n  #endif\n  }\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  void CCSurfacesLightingCalculateDirectTT(inout LightingResult lightingResult, in LightingIntermediateData lightingData, in vec4 lightSourceColorAndIntensity)\n  {\n    lightingResult.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLighting;\n    float w = lightingData.ttIntensity;\n    vec3 scatteredLighting = pow(saturate(lightingData.baseColorTT * w + lightingData.NoLSat) * lightingData.NoLSat, vec3(mix(0.5, 0.5 + lightingData.ttScatterCoef, w)));\n    vec3 ttLighting = scatteredLighting - lightingData.NoLSat;\n    lightingResult.directTT = ttLighting * DiffuseCoefficient_EnergyConservation * lightSourceColorAndIntensity.xyz* lightSourceColorAndIntensity.w;\n  }\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_BASECOLOR_AND_TRANSPARENCY\nvec4 SurfacesFragmentModifyBaseColorAndTransparency()\n{\n    return FSInput_vertexColor;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\nvec3 SurfacesFragmentModifyWorldNormal()\n{\n    return normalize(FSInput_worldNormal);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_WORLD_TANGENT_AND_BINORMAL\nvoid SurfacesFragmentModifyWorldTangentAndBinormal(inout vec3 worldTangent, inout vec3 worldBinormal, vec3 worldNormal)\n{\n    vec3 tangent = normalize(FSInput_worldTangent);\n#if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 binormal = normalize(CalculateBinormal(worldNormal.xyz, tangent, FSInput_mirrorNormal));\n    tangent = normalize(cross(binormal, worldNormal));\n#else\n    vec3 binormal = vec3(0.0, 0.0, 0.0);\n#endif\n    worldTangent = tangent;\n    worldBinormal = binormal;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_IOR\nfloat SurfacesFragmentModifyIOR()\n{\n    return 1.0;\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_ANISOTROPY_PARAMS\nvec4 SurfacesFragmentModifyAnisotropyParams(out float isRotation)\n{\n    isRotation = 1.0;\n    return vec4(1.0, 0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\nvec3 SurfacesFragmentModifyEmissive()\n{\n    return vec3(0.0, 0.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_PBRPARAMS\nvec4 SurfacesFragmentModifyPBRParams()\n{\n    return vec4(1.0, 0.5, 0.0, 0.5);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_SCATTERING_PARAMS\nvec4 SurfacesFragmentModifyTransmitScatteringParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_IN_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitInScatteringColor()\n{\n    return vec3(0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_OUT_SCATTERING_COLOR\nvec3 SurfacesFragmentModifyTransmitOutScatteringColor()\n{\n    return vec3(1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRANSMIT_DIFFUSE_PARAMS\nvec4 SurfacesFragmentModifyTransmitDiffuseParams()\n{\n    return vec4(1.0, 1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_PARAMS\nvec4 SurfacesFragmentModifyTRTParams()\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TRT_COLOR\nvec3 SurfacesFragmentModifyTRTColor()\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_PARAMS\nvec4 SurfacesFragmentModifyTTParams()\n{\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_TT_COLOR\nvec3 SurfacesFragmentModifyTTColor(in vec3 baseColor)\n{\n    return vec3(1.0, 1.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_DUAL_LOBE_SPECULAR_PARAMS\nvec4 SurfacesFragmentModifyDualLobeSpecularParams(float roughness)\n{\n    return vec4(0.2, 0.0, 0.0, 1.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SSS_PARAMS\nvec4 SurfacesFragmentModifySSSParams()\n{\n    return vec4(1.0, 0.1, 1.0, 0.0);\n}\n#endif\n#ifndef CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nvoid SurfacesFragmentModifySharedData(inout SurfacesMaterialData surfaceData)\n{\n}\n#endif\nvoid CCSurfacesFragmentGetMaterialData(inout SurfacesMaterialData surfaceData)\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part, FSInput_worldPos);\n  #else\n  surfaceData.worldPos = FSInput_worldPos;\n  #endif\n  surfaceData.baseColor = SurfacesFragmentModifyBaseColorAndTransparency();\n  surfaceData.worldNormal = SurfacesFragmentModifyWorldNormal();\n  SurfacesFragmentModifyWorldTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal);\n  surfaceData.ior = SurfacesFragmentModifyIOR();\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float isRotation;\n  vec4 anisotropyParams = SurfacesFragmentModifyAnisotropyParams(isRotation);\n  surfaceData.anisotropyShape = anisotropyParams.x;\n  if (isRotation > 0.0) {\n    RotateTangentAndBinormal(surfaceData.worldTangent, surfaceData.worldBinormal, surfaceData.worldNormal, anisotropyParams.y);\n  } else {\n    vec3 anisoDirTS = anisotropyParams.yzw;\n    vec3 tangentWS = anisoDirTS.x * surfaceData.worldTangent + anisoDirTS.y * surfaceData.worldBinormal + anisoDirTS.z * surfaceData.worldNormal;\n    surfaceData.worldTangent = normalize(tangentWS);\n    surfaceData.worldBinormal = cross(surfaceData.worldNormal, tangentWS);\n  }\n#endif\n  surfaceData.emissive = SurfacesFragmentModifyEmissive();\n  vec4 pbr = SurfacesFragmentModifyPBRParams();\n  surfaceData.ao = pbr.x;\n  surfaceData.roughness = pbr.y;\n  surfaceData.metallic = pbr.z;\n  surfaceData.specularIntensity = pbr.w;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitScatteringParams = SurfacesFragmentModifyTransmitScatteringParams();\n  surfaceData.inScatteringColor = SurfacesFragmentModifyTransmitInScatteringColor();\n  surfaceData.outScatteringColor = SurfacesFragmentModifyTransmitOutScatteringColor();\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  surfaceData.transmitDiffuseParams = SurfacesFragmentModifyTransmitDiffuseParams();\n#endif\n#if CC_SURFACES_LIGHTING_TRT\n  vec4 trtParams = SurfacesFragmentModifyTRTParams();\n  surfaceData.roughness2ndSpecular = saturate(surfaceData.roughness + trtParams.x);\n  surfaceData.intensity2ndSpecular = trtParams.w;\n  surfaceData.baseColor2ndSpecular = vec3(1.0);\n  surfaceData.color2ndSpecular = SurfacesFragmentModifyTRTColor();\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n  RotateNormalAndBinormal(surfaceData.worldBinormal2ndSpecular, surfaceData.worldNormal2ndSpecular, surfaceData.worldTangent2ndSpecular, trtParams.y, FSInput_mirrorNormal);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec4 ttParams = SurfacesFragmentModifyTTParams();\n  surfaceData.ttScatterCoef = ttParams.x;\n  surfaceData.ttIntensity = ttParams.w;\n  surfaceData.baseColorTT = SurfacesFragmentModifyTTColor(surfaceData.baseColor.rgb);\n#endif\n#if CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  vec4 dualLobeParams = SurfacesFragmentModifyDualLobeSpecularParams(surfaceData.roughness);\n  surfaceData.roughness2ndSpecular = saturate(dualLobeParams.x);\n  surfaceData.intensity2ndSpecular = dualLobeParams.w;\n  surfaceData.baseColor2ndSpecular = surfaceData.baseColor.rgb;\n  surfaceData.color2ndSpecular = vec3(1.0);\n  surfaceData.worldNormal2ndSpecular = surfaceData.worldNormal;\n  surfaceData.worldTangent2ndSpecular = surfaceData.worldTangent;\n  surfaceData.worldBinormal2ndSpecular = surfaceData.worldBinormal;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  surfaceData.sssParams = SurfacesFragmentModifySSSParams();\n#endif\n  SurfacesFragmentModifySharedData(surfaceData);\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP) {\n      surfaceData.worldNormal = normalize(FSInput_worldNormal);\n      surfaceData.worldTangent = normalize(FSInput_worldTangent);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW\n  if (!IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO)\n  {\n      surfaceData.baseColor.rgb = vec3(1.0);\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        surfaceData.baseColor2ndSpecular.rgb = vec3(1.0);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        surfaceData.baseColorTT.rgb = vec3(1.0);\n      #endif\n  }\n#endif\n}\nvec3 CCSurfacesGetDiffuseColor(in SurfacesMaterialData surfaceData)\n{\n  return surfaceData.baseColor.rgb * (1.0 - surfaceData.metallic);\n}\nvec3 CCSurfacesGetSpecularColor(in SurfacesMaterialData surfaceData)\n{\n  float F0 = surfaceData.specularIntensity * 0.08;\n  return mix(vec3(F0), surfaceData.baseColor.rgb, surfaceData.metallic);\n}\nvoid CCSurfacesLightingInitializeColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n  diffuseColorWithLighting = CCSurfacesGetDiffuseColor(surfaceData);\n  specularColorWithLighting = CCSurfacesGetSpecularColor(surfaceData).xyz;\n  specularColorWithEnvLighting = IntegratedGFApprox(specularColorWithLighting, surfaceData.roughness, lightingData.NoVAbsSat);\n}\nvoid CCSurfacesLightingCalculateColorWithLighting(inout vec3 diffuseColorWithLighting, inout vec3 specularColorWithLighting, inout vec3 specularColorWithEnvLighting, in SurfacesMaterialData surfaceData, in LightingIntermediateData lightingData)\n{\n}\nvoid CCSurfacesInitializeLightingIntermediateData(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  vec3 worldPos;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n  #else\n  worldPos = surfaceData.worldPos;\n  #endif\n  CCSurfacesLightingGetIntermediateData_PerPixel(lightingData, surfaceData.worldNormal, worldPos, surfaceData.worldTangent, surfaceData.worldBinormal\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n      , surfaceData.anisotropyShape\n#endif\n  );\n  lightingData.specularParam = surfaceData.roughness;\n  lightingData.ior = surfaceData.ior;\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitScatteringParams = surfaceData.transmitScatteringParams;\n  lightingData.inScatteringColor = surfaceData.inScatteringColor;\n  lightingData.outScatteringColor = surfaceData.outScatteringColor;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingData.transmitDiffuseParams = surfaceData.transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingData.baseColorTT = surfaceData.baseColorTT;\n  lightingData.ttIntensity = surfaceData.ttIntensity;\n  lightingData.ttScatterCoef = surfaceData.ttScatterCoef;\n#endif\n}\nvoid CCSurfacesLightingCalculateIntermediateData_PerLight(inout LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData, vec3 lightDirWithDist)\n{\n  CCSurfacesLightingGetIntermediateData_PerLight(lightingData, lightDirWithDist);\n}\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\nvoid CCSurfacesGetLightingIntermediateDataTransmitDiffuse(inout LightingIntermediateData lightingDataTD, in LightingIntermediateData lightingData, in SurfacesMaterialData surfaceData)\n{\n  lightingDataTD = lightingData;\n  lightingDataTD.N = lightingData.transmitScatteringParams.z > 0.0 ? -FSInput_worldNormal : -(normalize(FSInput_worldNormal)+lightingData.V);\n  lightingDataTD.N = normalize(lightingDataTD.N);\n}\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\nvoid CCSurfacesGetSurfacesMaterialData2ndSpecular(inout SurfacesMaterialData surfaceData2ndSpecular, in SurfacesMaterialData surfaceData)\n{\n  surfaceData2ndSpecular = surfaceData;\n  surfaceData2ndSpecular.baseColor = vec4(surfaceData.baseColor2ndSpecular, 1.0);\n  surfaceData2ndSpecular.roughness = surfaceData.roughness2ndSpecular;\n  surfaceData2ndSpecular.worldNormal = surfaceData.worldNormal2ndSpecular;\n  surfaceData2ndSpecular.worldTangent = surfaceData.worldTangent2ndSpecular;\n  surfaceData2ndSpecular.worldBinormal = surfaceData.worldBinormal2ndSpecular;\n}\n#endif\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData)\n{\n  lightingResult.ao = surfaceData.ao;\n  lightingResult.emissive = surfaceData.emissive;\n}\nvoid CCSurfacesInitializeLightingResult(inout LightingResult lightingResult)\n{\n  lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  lightingResult.directTransmitSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  lightingResult.directTransmitDiffuse = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  lightingResult.direct2ndSpecular = vec3(0.0);\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  lightingResult.directTT = vec3(0.0);\n#endif\n}\nvoid CCSurfacesAccumulateLightingResult(inout LightingResult lightingResultAccumulated, in LightingResult lightingResult)\n{\n  lightingResultAccumulated.directDiffuse += lightingResult.directDiffuse * lightingResult.shadow;\n  lightingResultAccumulated.directSpecular += lightingResult.directSpecular * lightingResult.shadow;\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    lightingResultAccumulated.directTransmitSpecular += lightingResult.directTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    lightingResultAccumulated.directTransmitDiffuse += lightingResult.directTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    lightingResultAccumulated.direct2ndSpecular += lightingResult.direct2ndSpecular * lightingResult.shadow;\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    lightingResultAccumulated.directTT += lightingResult.directTT * lightingResult.shadow;\n    lightingResultAccumulated.diffuseColorWithLightingTT = lightingResult.diffuseColorWithLightingTT;\n  #endif\n}\n#if CC_PIPELINE_TYPE == 1\n  vec4 CCSurfacesDeferredOutputBaseColor(in SurfacesMaterialData surfaceData)\n  {\n    return surfaceData.baseColor;\n  }\n  vec4 CCSurfacesDeferredOutputNormalMR(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(float32x3_to_oct(surfaceData.worldNormal), surfaceData.roughness, surfaceData.metallic);\n  }\n  vec4 CCSurfacesDeferredOutputEmissiveAO(in SurfacesMaterialData surfaceData)\n  {\n    return vec4(surfaceData.emissive, surfaceData.ao);\n  }\n#endif\nvec4 CCSurfacesShading(in SurfacesMaterialData surfaceData, in LightingResult lightingResult)\n{\n  vec4 color = vec4(0.0, 0.0, 0.0, surfaceData.baseColor.a);\n#if CC_FORWARD_ADD\n  color.xyz += lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n#else\n  float fresnel = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  float invFresnel = 1.0 - fresnel;\n  color.xyz +=\n    ( lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.directTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.direct2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    + lightingResult.directTT * lightingResult.diffuseColorWithLightingTT\n  #endif\n    )\n    * lightingResult.shadow\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.directTransmitDiffuse\n  #endif\n  ;\n  #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_ALL_IN_ONE\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting * lightingResult.shadow;\n  #elif CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n    color.xyz += lightingResult.lightmapColor * lightingResult.diffuseColorWithLighting;\n  #endif\n  color.xyz +=\n    ( lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting\n    + lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting * fresnel\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    + lightingResult.environmentTransmitSpecular * lightingResult.specularColorWithEnvLighting * invFresnel\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    + lightingResult.environment2ndSpecular * lightingResult.specularColorWithEnvLighting2ndSpecular * surfaceData.color2ndSpecular\n  #endif\n    )\n    * lightingResult.ao\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    + lightingResult.environmentTransmitDiffuse\n  #endif\n  ;\n  color.xyz += lightingResult.emissive;\n#endif\n  return color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\nbool CCSurfacesDebugViewSurfaceData(inout vec4 color, in SurfacesMaterialData surfaceData)\n{\n    bool enableMaterialAlpha = true;\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    float scalar;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(surfaceData.worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(surfaceData.worldBinormal * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSPARENCY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.baseColor.a;\n        color = vec4(scalar, scalar, scalar, 1.0);\n        enableMaterialAlpha = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_BASE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(surfaceData.baseColor.rgb), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetDiffuseColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(LinearToSRGB(CCSurfacesGetSpecularColor(surfaceData)), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ROUGHNESS)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.roughness;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_METALLIC)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.metallic;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.specularIntensity;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_IOR)) && (cc_surfaceTransform.y != 3.0))) {\n        scalar = surfaceData.ior - 1.0;\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    return enableMaterialAlpha;\n}\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    void CCSurfacesLighting(inout LightingResult lightingResultAccumulated, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      CCSurfacesInitializeLightingResult(lightingResultAccumulated);\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      LightingResult lightingResult;\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      lightingResultAccumulated.diffuseColorWithLighting = lightingResult.diffuseColorWithLighting;\n      lightingResultAccumulated.specularColorWithLighting = lightingResult.specularColorWithLighting;\n      lightingResultAccumulated.specularColorWithEnvLighting = lightingResult.specularColorWithEnvLighting;\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        vec3 diff;\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResultAccumulated.specularColorWithLighting2ndSpecular, lightingResultAccumulated.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData);\n      #endif\n      int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n      for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n        if (i >= numLights) break;\n        vec3 lightDirWithLength = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -normalize(cc_lightDir[i].xyz) : cc_lightPos[i].xyz - worldPos;\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, lightDirWithLength);\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        vec3 diffuseLighting, specularLighting;\n        CCSurfacesLightingCalculateDirect(diffuseLighting, specularLighting, lightingData, cc_lightColor[i]);\n        float fresnel = 1.0;\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        fresnel = lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n        float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_lightPos[i].w > 0.0 && cc_lightSizeRangeAngle[i].w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n            shadow = CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            vec3 shadowNDCPos;\n            bool isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Perspective(shadowNDCPos.z, shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Perspective(SampleShadowMapSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy), shadowPosWithDepthBias.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          shadow = 1.0;\n      #endif\n        lightingResult.shadow = shadow;\n        float distAtt = 1.0;\n        if(IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n          distAtt = GetOutOfRange(worldPos, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n        } else {\n          distAtt = CCSurfacesLightingCalculateDistanceAttenuation(lightingData, cc_lightSizeRangeAngle[i], cc_lightPos[i].w);\n        }\n        float angleAtt = 1.0;\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          angleAtt = CCSurfacesLightingCalculateAngleAttenuation(lightingData, cc_lightSizeRangeAngle[i], -cc_lightDir[i].xyz);\n        }\n        float multiplier = distAtt * angleAtt;\n        lightingData.angleAttenuation = angleAtt;\n        lightingData.distAttenuation = distAtt;\n        lightingResult.directDiffuse = diffuseLighting * multiplier;\n        lightingResult.directSpecular = specularLighting * multiplier * fresnel;\n        vec4 attenuatedLightColorAndIntensity = vec4(cc_lightColor[i].xyz, cc_lightColor[i].w * multiplier);\n        #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n          vec3 transmitSpecularLighting;\n          CCSurfacesLightingCalculateDirectTransmitSpecular(transmitSpecularLighting, lightingData, attenuatedLightColorAndIntensity);\n          lightingResult.directTransmitSpecular = transmitSpecularLighting * multiplier * (1.0 - fresnel);\n        #endif\n        #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n          LightingIntermediateData lightingDataTD;\n          CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, attenuatedLightColorAndIntensity, lightingResult.shadow);\n        #endif\n        #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n          LightingIntermediateData lightingData2ndSpecular;\n          CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n          CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData, lightDirWithLength);\n          CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, attenuatedLightColorAndIntensity, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n          lightingResult.direct2ndSpecular *= multiplier * fresnel;\n        #endif\n        #if CC_SURFACES_LIGHTING_TT\n          CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, attenuatedLightColorAndIntensity);\n        #endif\n        #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n          LightingMiscData miscData;\n          miscData.lightType = cc_lightPos[i].w;\n          miscData.lightPos = cc_lightPos[i].xyz;\n          miscData.lightDir = cc_lightDir[i].xyz;\n          miscData.lightColorAndIntensity = cc_lightColor[i];\n          miscData.lightSizeRangeAngle = cc_lightSizeRangeAngle[i];\n          SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n        #endif\n        CCSurfacesAccumulateLightingResult(lightingResultAccumulated, lightingResult);\n      }\n    }\n  #else\n    void CCSurfacesLighting(inout LightingResult lightingResult, in SurfacesMaterialData surfaceData, in vec2 shadowBias)\n    {\n      vec3 worldPos;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      worldPos = unpackHighpData(surfaceData.worldPos, surfaceData.worldPos_fract_part);\n      #else\n      worldPos = surfaceData.worldPos;\n      #endif\n      LightingIntermediateData lightingData;\n      CCSurfacesInitializeLightingIntermediateData(lightingData, surfaceData);\n      CCSurfacesInitializeLightingResult(lightingResult, surfaceData);\n      CCSurfacesLightingInitializeColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n      CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData, surfaceData, -cc_mainLitDir.xyz);\n      lightingResult.shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (cc_mainLitDir.w > 0.0) {\n          vec4 shadowPos = vec4(0.0), shadowPosWithDepthBias = vec4(0.0);\n          vec4 shadowProjDepthInfo = vec4(0.0);\n          vec3 shadowNDCPos;\n          bool isExceedShadowMap = true;\n          if (CCSurfacesLightingEnableShadow(lightingData.NoL)) {\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n              lightingResult.shadow = CCCSMFactorBase(worldPos, lightingData.N, shadowBias);\n              #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n                vec4 shadowProjInfo;\n                vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n                isExceedShadowMap = 0 > CCGetCSMLevel(shadowPosWithDepthBias, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n                GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n              #endif\n            #endif\n            #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n              shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n              lightingResult.shadow = CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, lightingData.N, shadowBias);\n              shadowProjDepthInfo = cc_shadowProjDepthInfo;\n              isExceedShadowMap = !GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias);\n            #endif\n          }\n          #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE && CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n            lightingData.shadowPosAndDepth.xy = shadowNDCPos.xy;\n            lightingData.shadowPosAndDepth.z = isExceedShadowMap ? 0.0 : GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowNDCPos.z, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n            lightingData.shadowPosAndDepth.w = isExceedShadowMap ? lightingData.shadowPosAndDepth.w : GetViewSpaceDepthFromNDCDepth_Orthgraphic(SampleShadowMapSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy), shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          #endif\n        }\n      #endif\n      lightingResult.lightmapColor = vec3(0.0);\n      #if CC_SURFACES_USE_LIGHT_MAP && !CC_FORWARD_ADD\n        float lightmapShadow, lightmapAO;\n        GetLightMapColor(lightingResult.lightmapColor, lightmapShadow, lightmapAO, cc_lightingMap, FSInput_lightMapUV.xy, FSInput_lightMapUV.z, surfaceData.worldNormal);\n        #if CC_SURFACES_USE_LIGHT_MAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n          lightingResult.shadow *= lightmapShadow;\n        #endif\n        lightingResult.ao *= lightmapAO;\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n          lightingResult.shadow = 1.0;\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n          lightingResult.ao = 1.0;\n      #endif\n      lightingResult.directDiffuse = lightingResult.directSpecular = vec3(0.0);\n      #if !CC_DISABLE_DIRECTIONAL_LIGHT && !CC_FORWARD_ADD\n        CCSurfacesLightingCalculateColorWithLighting(lightingResult.diffuseColorWithLighting, lightingResult.specularColorWithLighting, lightingResult.specularColorWithEnvLighting, surfaceData, lightingData);\n        CCSurfacesLightingCalculateDirect(lightingResult.directDiffuse, lightingResult.directSpecular, lightingData, cc_mainLitColor);\n      #endif\n      CCSurfacesLightingCalculateEnvironment(lightingResult.environmentDiffuse, lightingResult.environmentSpecular, lightingData, cc_ambientSky.w);\n      #if CC_SURFACES_LIGHTING_USE_FRESNEL\n        lightingResult.fresnel = CCSurfaceLightingCalculateFresnel(lightingData);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n        CCSurfacesLightingCalculateDirectTransmitSpecular(lightingResult.directTransmitSpecular, lightingData, cc_mainLitColor);\n        CCSurfacesLightingCalculateEnvironmentTransmitSpecular(lightingResult.environmentTransmitSpecular, lightingData, cc_ambientSky.w);\n      #endif\n      #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n        LightingIntermediateData lightingDataTD;\n        CCSurfacesGetLightingIntermediateDataTransmitDiffuse(lightingDataTD, lightingData, surfaceData);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingDataTD, surfaceData, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirectTransmitDiffuse(lightingResult.directTransmitDiffuse, lightingDataTD, cc_mainLitColor, lightingResult.shadow);\n        CCSurfacesLightingCalculateEnvironmentTransmitDiffuse(lightingResult.environmentTransmitDiffuse, lightingDataTD, cc_ambientSky.w, lightingResult.ao, -cc_mainLitDir.xyz);\n      #endif\n      #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n        SurfacesMaterialData surfaceData2ndSpecular;\n        CCSurfacesGetSurfacesMaterialData2ndSpecular(surfaceData2ndSpecular, surfaceData);\n        LightingIntermediateData lightingData2ndSpecular;\n        CCSurfacesInitializeLightingIntermediateData(lightingData2ndSpecular, surfaceData2ndSpecular);\n        CCSurfacesLightingCalculateIntermediateData_PerLight(lightingData2ndSpecular, surfaceData2ndSpecular, -cc_mainLitDir.xyz);\n        CCSurfacesLightingCalculateDirect2ndSpecular(lightingResult.direct2ndSpecular, lightingData2ndSpecular, cc_mainLitColor, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.directSpecular);\n        CCSurfacesLightingCalculateEnvironment2ndSpecular(lightingResult.environment2ndSpecular, lightingData2ndSpecular, cc_ambientSky.w, surfaceData2ndSpecular.intensity2ndSpecular, lightingResult.environmentSpecular);\n        vec3 diff;\n        CCSurfacesLightingInitializeColorWithLighting(diff, lightingResult.specularColorWithLighting2ndSpecular, lightingResult.specularColorWithEnvLighting2ndSpecular, surfaceData2ndSpecular, lightingData2ndSpecular);\n      #endif\n      #if CC_SURFACES_LIGHTING_TT\n        CCSurfacesLightingCalculateDirectTT(lightingResult, lightingData, cc_mainLitColor);\n      #endif\n      #ifdef CC_SURFACES_LIGHTING_MODIFY_FINAL_RESULT\n        LightingMiscData miscData;\n        miscData.lightType = LIGHT_TYPE_DIRECTIONAL;\n        miscData.lightPos = vec3(0.0);\n        miscData.lightDir = cc_mainLitDir.xyz;\n        miscData.lightColorAndIntensity = cc_mainLitColor;\n        miscData.lightSizeRangeAngle = vec4(0.0, 0.0, 0.0, 0.0);\n        SurfacesLightingModifyFinalResult(lightingResult, lightingData, surfaceData, miscData);\n      #endif\n    }\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING\n    #endif\n  #endif\n#endif\nvec4 CCSurfacesDebugDisplayInvalidNumber(vec4 color)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(color.rgb) || isinfs(color.rgb)) ? error : color;\n}\nvec4 CCSurfacesDebugDisplayInvalidInputData(vec4 color, vec3 data)\n{\n  float index = mod(cc_time.x * 10.0, 2.0);\n  vec4 error = index < 1.0 ? vec4(1.0, 0.0, 0.2, 1.0) : vec4(0.0, 1.0, 0.2, 1.0);\n  return (isnans(data) || isinfs(data)) ? error : color;\n}\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && !CC_FORWARD_ADD\n  void CCSurfacesDebugViewMeshData(inout vec4 color)\n  {\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_VERTEX_COLOR\n        color = FSInput_vertexColor;\n      #else\n        color = white;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_worldNormal * 0.5 + vec3(0.5), 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = vec4(FSInput_worldTangent * 0.5 + vec3(0.5), 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        float sign = FSInput_mirrorNormal * 0.5 + 0.5;\n        color = vec4(sign, sign, sign, 1.0);\n      #else\n        color = black;\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FACE_SIDE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        float scalar = clamp(FSInput_faceSideSign, 0.0, 1.0);\n        color = vec4(scalar, scalar, scalar, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV0)) && (cc_surfaceTransform.y != 3.0)))\n        color = vec4(FSInput_texcoord.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UV1)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_texcoord1.xy, 0.0, 1.0);\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n        color = vec4(FSInput_lightMapUV.xy, 0.0, 1.0);\n      #else\n        color = vec4(0.0, 0.0, 0.0, 1.0);\n      #endif\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 clipPos = cc_matProj * cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = clipPos.z / clipPos.w;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH)) && (cc_surfaceTransform.y != 3.0)))\n    {\n      vec4 viewPos = cc_matView * vec4(FSInput_worldPos.xyz, 1.0);\n      float depth = (-viewPos.z - cc_nearFar.x) / cc_nearFar.y;\n      color = vec4(depth, depth, depth, 1.0);\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_WORLD_POS)) && (cc_surfaceTransform.y != 3.0)))\n      color = vec4(FSInput_worldPos.xyz, 1.0);\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE\n  bool CCSurfacesDebugViewLightingResult(inout vec4 color, in LightingResult lightingResult)\n  {\n    bool isSRGBColor = false;\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.directDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.directSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentSpecular * lightingResult.specularColorWithEnvLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENV_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.environmentDiffuse * lightingResult.diffuseColorWithLighting + lightingResult.environmentSpecular * lightingResult.specularColorWithLighting;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_LIGHT_MAP)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.lightmapColor;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_EMISSIVE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = lightingResult.emissive;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_AO)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.ao);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_SHADOW)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(lightingResult.shadow);\n        isSRGBColor = false;\n    }\n    float fresnel = 0.0;\n    vec3 directTransmitSpecular = vec3(0.0), environmentTransmitSpecular = vec3(0.0);\n    vec3 directTransmitDiffuse = vec3(0.0), environmentTransmitDiffuse = vec3(0.0);\n    vec3 diffuseColorWithLightingTT = vec3(0.0), specularColorWithLighting2ndSpecular = vec3(0.0);\n    vec3 direct2ndSpecular = vec3(0.0), environment2ndSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    fresnel = lightingResult.fresnel;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    directTransmitSpecular = lightingResult.directTransmitSpecular;\n    environmentTransmitSpecular = lightingResult.environmentTransmitSpecular;\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    directTransmitDiffuse = lightingResult.directTransmitDiffuse;\n    environmentTransmitDiffuse = lightingResult.environmentTransmitDiffuse;\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    direct2ndSpecular = lightingResult.direct2ndSpecular;\n    environment2ndSpecular = lightingResult.environment2ndSpecular;\n    specularColorWithLighting2ndSpecular = lightingResult.specularColorWithEnvLighting2ndSpecular;\n  #endif\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FRESNEL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = vec3(fresnel);\n        isSRGBColor = false;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = directTransmitSpecular + environmentTransmitSpecular + directTransmitDiffuse + environmentTransmitDiffuse;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = direct2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = environment2ndSpecular * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL)) && (cc_surfaceTransform.y != 3.0)))\n    {\n        color.rgb = (direct2ndSpecular + environment2ndSpecular) * specularColorWithLighting2ndSpecular;\n        isSRGBColor = true;\n    }\n    return isSRGBColor;\n  }\n#endif\n#if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  void CCSurfacesDebugViewCompositeLightingResult(inout LightingResult lightingResult)\n  {\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE)\n      lightingResult.directDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR)\n      lightingResult.directSpecular = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE)\n      lightingResult.environmentDiffuse = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR)\n      lightingResult.environmentSpecular = vec3(0.0);\n  #if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE)\n      lightingResult.directTransmitDiffuse = lightingResult.environmentTransmitDiffuse = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR)\n      lightingResult.directTransmitSpecular = lightingResult.environmentTransmitSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR)\n        lightingResult.direct2ndSpecular = lightingResult.environment2ndSpecular = vec3(0.0);\n  #endif\n  #if CC_SURFACES_LIGHTING_TT\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT)\n        lightingResult.directTT = vec3(0.0);\n  #endif\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE)\n      lightingResult.emissive = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP)\n      lightingResult.lightmapColor = vec3(0.0);\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW)\n      lightingResult.shadow = 1.0;\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO)\n      lightingResult.ao = 1.0;\n  #if CC_SURFACES_LIGHTING_USE_FRESNEL\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL)\n      lightingResult.fresnel = 1.0;\n  #endif\n  }\n#endif\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main()  {\n  #if CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER\n    float NoL = dot(-cc_mainLitDir.xyz, FSInput_worldNormal.xyz);\n    vec4 color = SurfacesFragmentModifyBaseColorAndTransparency();\n    float fogFactor = 1.0;\n    #if CC_FORWARD_ADD\n      color.rgb = vec3(0.0);\n    #endif\n  #else\n    SurfacesMaterialData surfaceData;\n    CCSurfacesFragmentGetMaterialData(surfaceData);\n    vec2 shadowBias = vec2(0.0);\n    vec3 colDebugCSMLayer = vec3(1.0);\n    #if CC_RECEIVE_SHADOW\n      shadowBias = FSInput_shadowBias;\n      #if !CC_FORWARD_ADD\n        #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n          if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION)\n          {\n              vec4 csmPos;\n              vec4 shadowProjDepthInfo, shadowProjInfo;\n              vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n              int csmLayer = -1;\n              csmLayer = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, surfaceData.worldPos);\n              bool OutOfRange = csmLayer < 0;\n              if (OutOfRange)\n                  colDebugCSMLayer = vec3(1.0);\n              else if (csmLayer == 0)\n                  colDebugCSMLayer = vec3(1.0, 0.0, 0.0);\n              else if (csmLayer == 1)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 0.0);\n              else if (csmLayer == 2)\n                  colDebugCSMLayer = vec3(0.0, 0.0, 1.0);\n              else if (csmLayer == 3)\n                  colDebugCSMLayer = vec3(0.0, 1.0, 1.0);\n          }\n        #endif\n      #endif\n    #endif\n    float fogFactor = 1.0;\n    #if !CC_FORWARD_ADD\n      #if CC_USE_FOG != 4\n        #if !CC_USE_ACCURATE_FOG\n          fogFactor = FSInput_fogFactor;\n        #else\n          CC_TRANSFER_FOG_BASE(vec4(FSInput_worldPos, 1.0), fogFactor);\n        #endif\n      #endif\n      #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n        if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG) {\n            fogFactor = 1.0;\n        }\n      #endif\n    #endif\n    LightingResult lightingResult;\n    CCSurfacesLighting(lightingResult, surfaceData, shadowBias);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      float materialTransparency = CCSurfacesShading(surfaceData, lightingResult).a;\n      #if !CC_FORWARD_ADD && !CC_SURFACES_LIGHTING_DISABLE_DIFFUSE\n        CCSurfacesDebugViewMeshData(debugColor);\n        if (CCSurfacesDebugViewSurfaceData(debugColor, surfaceData))\n        {\n          debugColor.a = materialTransparency;\n        }\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_FOG)) && (cc_surfaceTransform.y != 3.0)))\n        {\n          debugColor.rgb = vec3(1.0 - fogFactor);\n        }\n      #endif\n      #if CC_FORWARD_ADD\n        if ((equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_ALL)) && (cc_surfaceTransform.y != 3.0)) ||\n            (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR)) && (cc_surfaceTransform.y != 3.0)) || (equalf_mode(cc_debug_view_mode.x, float(CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR)) && (cc_surfaceTransform.y != 3.0)))\n      #endif\n        {\n            if (CCSurfacesDebugViewLightingResult(debugColor, lightingResult))\n            {\n              debugColor.a = materialTransparency;\n              #if !CC_USE_FLOAT_OUTPUT\n                debugColor.rgb = HDRToLDR(debugColor.rgb);\n                debugColor.rgb = LinearToSRGB(debugColor.rgb);\n              #endif\n            }\n        }\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n        return;\n      }\n    #elif CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n      CCSurfacesDebugViewCompositeLightingResult(lightingResult);\n    #endif\n    vec4 color = CCSurfacesShading(surfaceData, lightingResult);\n    #if CC_USE_DEBUG_VIEW && CC_SURFACES_ENABLE_DEBUG_VIEW\n      if (IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION) {\n          color.rgb *= colDebugCSMLayer.rgb;\n      }\n      #if CC_SURFACES_USE_TANGENT_SPACE\n        color = CCSurfacesDebugDisplayInvalidInputData(color, FSInput_worldTangent);\n      #endif\n    #endif\n  #endif\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG_BASE(color, fogFactor);\n      #endif\n    #endif\n    #if CC_USE_RGBE_OUTPUT\n      color = packRGBE(color.rgb);\n    #else\n      color = CCSurfacesDebugDisplayInvalidNumber(color);\n      #if !CC_USE_FLOAT_OUTPUT\n        color.rgb = HDRToLDR(color.rgb);\n        color.rgb = LinearToSRGB(color.rgb);\n      #endif\n    #endif\n    gl_FragData[0] = color;\n  }\n#elif CC_PIPELINE_TYPE == 1\n    void main () {\n      SurfacesMaterialData surfaceData;\n      CCSurfacesFragmentGetMaterialData(surfaceData);\n      gl_FragData[0] = CCSurfacesDeferredOutputBaseColor(surfaceData);\n      gl_FragData[2] = CCSurfacesDeferredOutputNormalMR(surfaceData);\n      gl_FragData[1] = CCSurfacesDeferredOutputEmissiveAO(surfaceData);\n    #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_SINGLE && CC_SURFACES_ENABLE_DEBUG_VIEW\n      vec4 debugColor = vec4(0.0, 0.0, 0.0, 1.0);\n      CCSurfacesDebugViewMeshData(debugColor);\n      CCSurfacesDebugViewSurfaceData(debugColor, surfaceData);\n      if (IS_DEBUG_VIEW_ENABLE_WITH_CAMERA) {\n        gl_FragData[0] = debugColor;\n      }\n    #endif\n    }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":103,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":133}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"HAS_EXPORTED_GLOSSINESS","type":"boolean"},{"name":"GLOSSINESS_MAP_USE_SINGLE_CHANNEL","type":"boolean"},{"name":"HAS_EXPORTED_METALLIC","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_DIFFUSE","type":"boolean"},{"name":"CC_SURFACES_LIGHTING_DISABLE_SPECULAR","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"}]},{"hash":4251869597,"name":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_color","format":44,"location":6,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":7,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":16,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":17,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":18,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"diffuseColor","type":16,"count":1},{"name":"specularColor","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScale","type":13,"count":1},{"name":"alphaThreshold","type":13,"count":1},{"name":"shininessExponent","type":13,"count":1},{"name":"glossiness","type":13,"count":1},{"name":"metallic","type":13,"count":1},{"name":"normalScale","type":13,"count":1},{"name":"transparencyFactor","type":13,"count":1},{"name":"diffuseFactor","type":13,"count":1},{"name":"specularFactor","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"shininessExponentMap","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_SHININESS_MAP"]},{"name":"specularGlossinessMap","type":28,"count":1,"stageFlags":16,"binding":2,"defines":["USE_SPECULAR_GLOSSINESS_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_SPECULAR_MAP"]},{"name":"metallicMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_METALLIC_MAP"]},{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_ALBEDO_MAP"]},{"name":"transparencyMap","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_TRANSPARENCY_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"emissiveScaleMap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_EMISSIVESCALE_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_NORMAL_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":10,"defines":["USE_OCCLUSION_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nout highp vec3 v_worldPos;\nout vec4 v_normal;\nout vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  out lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  out mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  out mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  out highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  out highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nout highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nin highp vec3 v_worldPos;\nin vec4 v_normal;\nin vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  in mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  in mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  in highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  in highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    layout(std140) uniform CCForwardLight {\n      highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n      vec4 cc_lightColor[LIGHTS_PER_PASS];\n      vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n      vec4 cc_lightDir[LIGHTS_PER_PASS];\n      vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n    };\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4  tilingOffset;\n  vec4  diffuseColor;\n  vec4  specularColor;\n  vec4  emissive;\n  float emissiveScale;\n  float alphaThreshold;\n  float shininessExponent;\n  float glossiness;\n  float metallic;\n  float normalScale;\n  float transparencyFactor;\n  float diffuseFactor;\n  float specularFactor;\n};\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nin highp vec2 v_clip_depth;\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    fragColorX = packDepthToRGBA(clipDepth);\n  #else\n    fragColorX = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  attribute vec4 a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  attribute vec4 a_color;\n#endif\n#if CC_SURFACES_USE_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define VSOutput_worldPos v_worldPos\n#define VSOutput_worldNormal v_normal.xyz\n#define VSOutput_faceSideSign v_normal.w\n#define VSOutput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define VSOutput_vertexColor v_color\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define VSOutput_worldTangent v_tangent.xyz\n  #define VSOutput_mirrorNormal v_tangent.w\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define VSOutput_texcoord1 v_uv1\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define VSOutput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define VSOutput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define VSOutput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define VSOutput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define VSOutput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define VSOutput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define VSOutput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define VSOutput_clipPos v_clipPos\n#endif\nstruct SurfacesStandardVertexIntermediate\n{\n  highp vec4 position;\n  vec3 normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  vec4 tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  vec4 color;\n#endif\n  vec2 texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  vec2 texCoord1;\n#endif\n  highp vec4 clipPos;\n  highp vec3 worldPos;\n  vec4 worldNormal;\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    vec3 worldTangent, worldBinormal;\n  #endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  vec4 shadowBiasAndProbeId;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  float fogFactor;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  vec3 lightmapUV;\n#endif\n};\n#if CC_USE_MORPH\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matLightViewProj;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #if CC_USE_FOG != 4\n  #endif\n#endif\n    uniform vec4 tilingOffset;\n#define CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n  In.texCoord = In.texCoord * tilingOffset.xy + tilingOffset.zw;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = In.texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\n}\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_POS\nvec3 SurfacesVertexModifyLocalPos(in SurfacesStandardVertexIntermediate In)\n{\n  return vec3(In.position.xyz);\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_TANGENT\n  #if CC_SURFACES_USE_TANGENT_SPACE\n  #endif\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_LOCAL_SHARED_DATA\nvoid SurfacesVertexModifyLocalSharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_POS\nvec3 SurfacesVertexModifyWorldPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.worldPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_CLIP_POS\nvec4 SurfacesVertexModifyClipPos(in SurfacesStandardVertexIntermediate In)\n{\n  return In.clipPos;\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_UV\nvoid SurfacesVertexModifyUV(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_WORLD_NORMAL\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHADOW_BIAS\n#endif\n#ifndef CC_SURFACES_VERTEX_MODIFY_SHARED_DATA\nvoid SurfacesVertexModifySharedData(inout SurfacesStandardVertexIntermediate In)\n{\n}\n#endif\nvoid CCSurfacesVertexInput(out SurfacesStandardVertexIntermediate In)\n{\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  In.tangent = a_tangent;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  In.color = a_color;\n#endif\n  In.texCoord = a_texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  In.texCoord1 = a_texCoord1;\n#endif\n}\nvoid CCSurfacesVertexOutput(in SurfacesStandardVertexIntermediate In)\n{\n  gl_Position = In.clipPos;\n  VSOutput_worldNormal = In.worldNormal.xyz;\n  VSOutput_faceSideSign = In.worldNormal.w;\n  VSOutput_worldPos = In.worldPos;\n#if CC_SURFACES_USE_TANGENT_SPACE\n  VSOutput_worldTangent = In.worldTangent.xyz;\n  VSOutput_mirrorNormal = In.tangent.w > 0.0 ? 1.0 : -1.0;\n#endif\n#if CC_SURFACES_USE_VERTEX_COLOR\n  VSOutput_vertexColor = In.color;\n#endif\n  VSOutput_texcoord = In.texCoord;\n#if CC_SURFACES_USE_SECOND_UV\n  VSOutput_texcoord1 = In.texCoord1;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  VSOutput_fogFactor = In.fogFactor;\n#endif\n#if CC_RECEIVE_SHADOW\n  VSOutput_shadowBias = In.shadowBiasAndProbeId.xy;\n#endif\n#if CC_USE_REFLECTION_PROBE\n  VSOutput_reflectionProbeId = In.shadowBiasAndProbeId.z;\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    VSOutput_reflectionProbeBlendId = In.shadowBiasAndProbeId.w;\n  #endif\n  #if USE_INSTANCING\n    v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  VSOutput_lightMapUV = In.lightmapUV;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  VSOutput_localPos = In.position;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  VSOutput_clipPos = In.clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\nvoid CCSurfacesVertexAnimation(inout SurfacesStandardVertexIntermediate In)\n{\nvec4 temp = vec4(0.0);\n#if CC_USE_MORPH\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    applyMorph(In.position, In.normal, In.tangent);\n  #else\n    applyMorph(In.position, In.normal, temp);\n  #endif\n#endif\n#if CC_USE_SKINNING\n  #if CC_SURFACES_USE_TANGENT_SPACE\n    CCSkin(In.position, In.normal, In.tangent);\n  #else\n    CCSkin(In.position, In.normal, temp);\n  #endif\n#endif\n}\nvoid CCSurfacesVertexWorldTransform(inout SurfacesStandardVertexIntermediate In)\n{\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    In.worldPos = (matWorld * In.position).xyz;\n    In.worldNormal.xyz = normalize((matWorldIT * vec4(In.normal.xyz, 0.0)).xyz);\n    #if CC_SURFACES_USE_TANGENT_SPACE\n      In.worldTangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      In.worldBinormal = cross(In.worldNormal.xyz, In.worldTangent) * In.tangent.w;\n    #endif\n}\nvoid CCSurfacesVertexTransformUV(inout SurfacesStandardVertexIntermediate In)\n{\n  #if CC_SURFACES_FLIP_UV\n    In.texCoord = cc_cameraPos.w > 1.0 ? vec2(In.texCoord.x, 1.0 - In.texCoord.y) : In.texCoord;\n    #if CC_SURFACES_USE_SECOND_UV\n      In.texCoord1 = cc_cameraPos.w > 1.0 ? vec2(In.texCoord1.x, 1.0 - In.texCoord1.y) : In.texCoord1;\n    #endif\n  #endif\n}\nvarying highp vec2 v_clip_depth;\nvoid main()\n{\n  SurfacesStandardVertexIntermediate In;\n  CCSurfacesVertexInput(In);\n  CCSurfacesVertexAnimation(In);\n  In.position.xyz = SurfacesVertexModifyLocalPos(In);\n  SurfacesVertexModifyLocalSharedData(In);\n  CCSurfacesVertexWorldTransform(In);\n  In.worldPos = SurfacesVertexModifyWorldPos(In);\n  In.clipPos = cc_matLightViewProj * vec4(In.worldPos, 1.0);\n  In.clipPos = SurfacesVertexModifyClipPos(In);\n  SurfacesVertexModifyUV(In);\n  SurfacesVertexModifySharedData(In);\n  CCSurfacesVertexTransformUV(In);\n  CCSurfacesVertexOutput(In);\n  v_clip_depth = In.clipPos.zw;\n}","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n  #define CC_SURFACES_USE_SECOND_UV HAS_SECOND_UV\n  #define CC_SURFACES_USE_TWO_SIDED USE_TWOSIDE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE USE_REFLECTION_DENOISE\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC IS_ANISOTROPY\n  #define CC_SURFACES_USE_VERTEX_COLOR USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING USE_COMPATIBLE_LIGHTING\n#if IS_ANISOTROPY || USE_NORMAL_MAP\n  #define CC_SURFACES_USE_TANGENT_SPACE 1\n#endif\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 31\n#ifndef CC_SURFACES_USE_SECOND_UV\n  #define CC_SURFACES_USE_SECOND_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TANGENT_SPACE\n  #define CC_SURFACES_USE_TANGENT_SPACE 0\n#endif\n#ifndef CC_SURFACES_USE_VERTEX_COLOR\n  #define CC_SURFACES_USE_VERTEX_COLOR 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_LOCAL_POS\n  #define CC_SURFACES_TRANSFER_LOCAL_POS 0\n#endif\n#ifndef CC_SURFACES_TRANSFER_CLIP_POS\n  #define CC_SURFACES_TRANSFER_CLIP_POS 0\n#endif\n#ifndef CC_SURFACES_USE_LIGHT_MAP\n  #ifdef CC_USE_LIGHTMAP\n    #define CC_SURFACES_USE_LIGHT_MAP CC_USE_LIGHTMAP\n  #else\n    #define CC_SURFACES_USE_LIGHT_MAP 0\n  #endif\n#endif\n#ifndef CC_SURFACES_FLIP_UV\n  #define CC_SURFACES_FLIP_UV 0\n#endif\n#ifndef CC_SURFACES_USE_TWO_SIDED\n  #define CC_SURFACES_USE_TWO_SIDED 0\n#endif\n#ifndef CC_SURFACES_USE_REFLECTION_DENOISE\n  #define CC_SURFACES_USE_REFLECTION_DENOISE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT\n  #define CC_SURFACES_LIGHTING_ANISOTROPIC_ENVCONVOLUTION_COUNT 0\n#endif\n#ifndef CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING\n  #define CC_SURFACES_USE_LEGACY_COMPATIBLE_LIGHTING 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_FRESNEL\n  #define CC_SURFACES_LIGHTING_USE_FRESNEL 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR\n  #define CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  #define CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT\n  #define CC_SURFACES_LIGHTING_USE_SHADOWMAP_TRANSMIT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TRT\n  #define CC_SURFACES_LIGHTING_TRT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR\n  #define CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_CLEAR_COAT\n  #define CC_SURFACES_LIGHTING_CLEAR_COAT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_TT\n  #define CC_SURFACES_LIGHTING_TT 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_SSS\n  #define CC_SURFACES_LIGHTING_SSS 0\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #if CC_SURFACES_LIGHTING_TRT || CC_SURFACES_LIGHTING_DUAL_LOBE_SPECULAR || CC_SURFACES_LIGHTING_CLEAR_COAT\n    #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 1\n  #endif\n#endif\n#ifndef CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  #define CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR 0\n#endif\n#ifndef CC_SURFACES_ENABLE_DEBUG_VIEW\n  #define CC_SURFACES_ENABLE_DEBUG_VIEW 1\n#endif\n#define CC_USE_SURFACE_SHADER 1\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvarying highp vec3 v_worldPos;\nvarying vec4 v_normal;\nvarying vec2 v_uv;\n#if CC_SURFACES_USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  varying mediump vec4 v_tangent;\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying mediump vec3 v_luv;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  varying mediump float v_fogFactor;\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  varying highp vec4 v_localPos;\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  varying highp vec4 v_clipPos;\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\n#define FSInput_worldPos v_worldPos\n#define FSInput_worldNormal v_normal.xyz\n#define FSInput_faceSideSign v_normal.w\n#define FSInput_texcoord v_uv\n#if CC_SURFACES_USE_VERTEX_COLOR\n  #define FSInput_vertexColor v_color\n#else\n  #define FSInput_vertexColor vec4(1.0)\n#endif\n#if CC_SURFACES_USE_TANGENT_SPACE\n  #define FSInput_worldTangent v_tangent.xyz\n  #define FSInput_mirrorNormal v_tangent.w\n#else\n  #define FSInput_worldTangent vec3(0.0, 0.0, 0.0)\n  #define FSInput_mirrorNormal 1.0\n#endif\n#if CC_SURFACES_USE_SECOND_UV\n  #define FSInput_texcoord1 v_uv1\n#else\n  #define FSInput_texcoord1 vec2(0.0, 0.0)\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  #define FSInput_lightMapUV v_luv\n#endif\n#if CC_RECEIVE_SHADOW\n  #define FSInput_shadowBias v_shadowBiasAndProbeId.xy\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #define FSInput_reflectionProbeId v_shadowBiasAndProbeId.z\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    #define FSInput_reflectionProbeBlendId v_shadowBiasAndProbeId.w\n  #endif\n  #if USE_INSTANCING\n    #define FSInput_reflectionProbeData v_reflectionProbeData\n  #endif\n#endif\n#if CC_USE_FOG != 4 && !CC_USE_ACCURATE_FOG\n  #define FSInput_fogFactor v_fogFactor\n#endif\n#if CC_SURFACES_TRANSFER_LOCAL_POS\n  #define FSInput_localPos v_localPos\n#endif\n#if CC_SURFACES_TRANSFER_CLIP_POS\n  #define FSInput_clipPos v_clipPos\n#endif\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_surfaceTransform;\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL CC_SURFACES_DEBUG_VIEW_VERTEX_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT CC_SURFACES_DEBUG_VIEW_VERTEX_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_WORLD_POS CC_SURFACES_DEBUG_VIEW_VERTEX_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR CC_SURFACES_DEBUG_VIEW_WORLD_POS + 1\n#define CC_SURFACES_DEBUG_VIEW_FACE_SIDE CC_SURFACES_DEBUG_VIEW_VERTEX_MIRROR + 1\n#define CC_SURFACES_DEBUG_VIEW_UV0 CC_SURFACES_DEBUG_VIEW_FACE_SIDE + 1\n#define CC_SURFACES_DEBUG_VIEW_UV1 CC_SURFACES_DEBUG_VIEW_UV0 + 1\n#define CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP CC_SURFACES_DEBUG_VIEW_UV1 + 1\n#define CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH CC_SURFACES_DEBUG_VIEW_UVLIGHTMAP + 1\n#define CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH CC_SURFACES_DEBUG_VIEW_PROJ_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL CC_SURFACES_DEBUG_VIEW_LINEAR_DEPTH + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT CC_SURFACES_DEBUG_VIEW_FRAGMENT_NORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL CC_SURFACES_DEBUG_VIEW_FRAGMENT_TANGENT + 1\n#define CC_SURFACES_DEBUG_VIEW_BASE_COLOR CC_SURFACES_DEBUG_VIEW_FRAGMENT_BINORMAL + 1\n#define CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR CC_SURFACES_DEBUG_VIEW_BASE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR CC_SURFACES_DEBUG_VIEW_DIFFUSE_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSPARENCY CC_SURFACES_DEBUG_VIEW_SPECULAR_COLOR + 1\n#define CC_SURFACES_DEBUG_VIEW_METALLIC CC_SURFACES_DEBUG_VIEW_TRANSPARENCY + 1\n#define CC_SURFACES_DEBUG_VIEW_ROUGHNESS CC_SURFACES_DEBUG_VIEW_METALLIC + 1\n#define CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY CC_SURFACES_DEBUG_VIEW_ROUGHNESS + 1\n#define CC_SURFACES_DEBUG_VIEW_IOR CC_SURFACES_DEBUG_VIEW_SPECULAR_INTENSITY + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_IOR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_ALL CC_SURFACES_DEBUG_VIEW_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_DIRECT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_ENV_ALL CC_SURFACES_DEBUG_VIEW_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_EMISSIVE CC_SURFACES_DEBUG_VIEW_ENV_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_LIGHT_MAP CC_SURFACES_DEBUG_VIEW_EMISSIVE + 1\n#define CC_SURFACES_DEBUG_VIEW_SHADOW CC_SURFACES_DEBUG_VIEW_LIGHT_MAP + 1\n#define CC_SURFACES_DEBUG_VIEW_AO CC_SURFACES_DEBUG_VIEW_SHADOW + 1\n#define CC_SURFACES_DEBUG_VIEW_FRESNEL CC_SURFACES_DEBUG_VIEW_AO + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE CC_SURFACES_DEBUG_VIEW_FRESNEL + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE CC_SURFACES_DEBUG_VIEW_TRANSMIT_DIRECT_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_DIFFUSE + 1\n#define CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL CC_SURFACES_DEBUG_VIEW_TRANSMIT_ENV_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_TRANSMIT_ALL + 1\n#define CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR CC_SURFACES_DEBUG_VIEW_DIRECT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL CC_SURFACES_DEBUG_VIEW_ENVIRONMENT_2ND_SPECULAR + 1\n#define CC_SURFACES_DEBUG_VIEW_FOG CC_SURFACES_DEBUG_VIEW_2ND_SPECULAR_ALL + 1\n#define IS_DEBUG_VIEW_ENABLE_WITH_CAMERA (cc_surfaceTransform.y != 3.0)\n#define IS_DEBUG_VIEW_LIGHTING_ENABLE_WITH_ALBEDO (UnpackBitFromFloat(cc_debug_view_mode.w, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_MISC_ENABLE_CSM_LAYER_COLORATION (UnpackBitFromFloat(cc_debug_view_mode.w, 7) && IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_DIRECT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.y, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_ENV_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.y, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_EMISSIVE (UnpackBitFromFloat(cc_debug_view_mode.y, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_LIGHT_MAP (UnpackBitFromFloat(cc_debug_view_mode.y, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_SHADOW (UnpackBitFromFloat(cc_debug_view_mode.y, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_AO (UnpackBitFromFloat(cc_debug_view_mode.y, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_NORMAL_MAP (UnpackBitFromFloat(cc_debug_view_mode.z, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FOG (UnpackBitFromFloat(cc_debug_view_mode.z, 1) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TONE_MAPPING (UnpackBitFromFloat(cc_debug_view_mode.z, 2) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION (UnpackBitFromFloat(cc_debug_view_mode.z, 3) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_FRESNEL (UnpackBitFromFloat(cc_debug_view_mode.z, 4) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_DIFFUSE (UnpackBitFromFloat(cc_debug_view_mode.z, 5) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TRANSMIT_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 6) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_2ND_SPECULAR (UnpackBitFromFloat(cc_debug_view_mode.z, 7) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#define IS_DEBUG_VIEW_COMPOSITE_ENABLE_TT (UnpackBitFromFloat(cc_debug_view_mode.w, 0) || !IS_DEBUG_VIEW_ENABLE_WITH_CAMERA)\n#if (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  #if CC_FORWARD_ADD\n    #if CC_PIPELINE_TYPE == 0\n      #define LIGHTS_PER_PASS 1\n    #else\n      #define LIGHTS_PER_PASS 10\n    #endif\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n    #endif\n  #endif\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if !USE_INSTANCING\n    #endif\n#endif\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform samplerCube cc_reflectionProbeBlendCubemap;\n#endif\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n#ifdef CC_USE_METAL\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n#endif\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_USE_FOG != 4\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  #endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  uniform sampler2D cc_lightingMap;\n#endif\n    uniform vec4 diffuseColor;\n    uniform vec4 emissive;\n    uniform float alphaThreshold;\n    uniform float metallic;\n    uniform float transparencyFactor;\n#define DCC_APP_OTHERS 0\n#define DCC_APP_MAX 1\n#define DCC_APP_BLENDER 2\n#define DCC_APP_CINEMA4D 3\n#define DCC_APP_GLTF 4\n#define DCC_APP_MAYA 5\n#if USE_SHININESS_MAP\n  uniform sampler2D shininessExponentMap;\n#endif\n#if USE_SPECULAR_GLOSSINESS_MAP\n  uniform sampler2D specularGlossinessMap;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n #if USE_METALLIC_MAP\n  uniform sampler2D metallicMap;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_TRANSPARENCY_MAP\n  uniform sampler2D transparencyMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_EMISSIVESCALE_MAP\n  uniform sampler2D emissiveScaleMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#define CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\nvoid SurfacesFragmentAlphaClipOnly()\n{\n    #if USE_ALPHA_TEST\n      float alpha = diffuseColor.a;\n      #if USE_VERTEX_COLOR\n        alpha *= FSInput_vertexColor.a;\n      #endif\n      #if USE_ALBEDO_MAP\n        alpha *= texture2D(albedoMap, TEXTURE_UV).a * transparencyFactor;\n      #endif\n      #if USE_TRANSPARENCY_MAP\n        alpha = texture2D(transparencyMap, TEXTURE_UV).TRANSPARENCY_MAP_CHANNEL;\n        #if DCC_APP_NAME == DCC_APP_MAYA\n          alpha = 1.0 - alpha;\n        #endif\n      #endif\n      if (alpha < alphaThreshold) discard;\n    #endif\n}\n#define CC_SURFACES_FRAGMENT_MODIFY_WORLD_NORMAL\n#define CC_SURFACES_FRAGMENT_MODIFY_EMISSIVE\n#define CC_SURFACES_FRAGMENT_MODIFY_SHARED_DATA\nstruct SurfacesMaterialData\n{\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 worldPos, worldPos_fract_part;\n  #else\n  vec3 worldPos;\n  #endif\n  vec4 baseColor;\n  vec3 worldNormal;\n  vec3 emissive;\n  float specularIntensity;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3 worldTangent, worldBinormal;\n  float ior;\n#if CC_SURFACES_LIGHTING_ANISOTROPIC\n  float anisotropyShape;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_SPECULAR || CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec3 outScatteringColor, inScatteringColor;\n  vec4 transmitScatteringParams;\n#endif\n#if CC_SURFACES_LIGHTING_TRANSMIT_DIFFUSE\n  vec4 transmitDiffuseParams;\n#endif\n#if CC_SURFACES_LIGHTING_2ND_LAYER_SPECULAR\n  vec3 baseColor2ndSpecular, color2ndSpecular;\n  float intensity2ndSpecular, roughness2ndSpecular;\n  vec3 worldNormal2ndSpecular, worldTangent2ndSpecular, worldBinormal2ndSpecular;\n#endif\n#if CC_SURFACES_LIGHTING_TT\n  vec3 baseColorTT;\n  float ttIntensity, ttScatterCoef;\n#endif\n#if CC_SURFACES_LIGHTING_SSS\n  vec4 sssParams;\n#endif\n};\nvarying highp vec2 v_clip_depth;\nvoid main () {\n#ifdef CC_SURFACES_FRAGMENT_ALPHA_CLIP_ONLY\n  SurfacesFragmentAlphaClipOnly();\n#endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(FSInput_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    gl_FragColor = packDepthToRGBA(clipDepth);\n  #else\n    gl_FragColor = vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]},{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeBlendCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":103,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":133}},"defines":[{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"IS_ANISOTROPY","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"USE_COMPATIBLE_LIGHTING","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_DISABLE_STRUCTURE_IN_FRAGMENT_SHADER","type":"number","range":[0,1]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"TEXTURE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"DCC_APP_NAME","type":"number","range":[0,5]},{"name":"USE_SHININESS_MAP","type":"boolean"},{"name":"GLOSSINESS_MAP_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_SPECULAR_GLOSSINESS_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_METALLIC_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"USE_TRANSPARENCY_MAP","type":"boolean"},{"name":"TRANSPARENCY_MAP_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_EMISSIVESCALE_MAP","type":"boolean"},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"OCCLUSION_CHANNEL","type":"string","options":["r","g","b","a"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]}],[{"name":"opaque","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","properties":{"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveMap":{"value":"grey","type":28},"emissiveScale":{"type":13,"value":[1]},"emissiveScaleMap":{"value":"grey","type":28},"shininessExponentMap":{"value":"grey","type":28},"shininessExponent":{"type":13,"value":[100]},"specularGlossinessMap":{"value":"grey","type":28},"specularColor":{"linear":true,"type":16,"value":[0,0,0,0]},"specularMap":{"value":"grey","type":28},"specularFactor":{"type":13,"value":[1]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"tilingOffset":{"type":16,"value":[1,1,0,0]},"normalStrength":{"type":13,"value":[1],"handleInfo":["normalScale",0,13]},"normalMap":{"value":"normal","type":28},"glossiness":{"type":13,"value":[0]},"metallic":{"type":13,"value":[0]},"metallicMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"albedoMap":{"type":28,"value":"grey"},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"normalScale":{"type":13,"value":[1]}}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"deferred-forward","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs"}]},{"name":"transparent","passes":[{"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}},{"phase":"forward-add","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|shadow-caster-vs|shadow-caster-fs","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["diffuseColor",0,16]},"albedoScale":{"type":13,"value":[1],"handleInfo":["diffuseFactor",0,13]},"alphaThreshold":{"type":13,"value":[0.5]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"transparencyMap":{"value":"grey","type":28},"transparencyFactor":{"type":13,"value":[1]},"diffuseColor":{"type":16,"value":[1,1,1,1]},"diffuseFactor":{"type":13,"value":[1]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"deferred-forward","propertyIndex":0,"program":"util/dcc/imported-specular-glossiness|standard-vs|standard-fs","embeddedMacros":{"CC_PIPELINE_TYPE":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}}]}]]],0,0,[],[],[]]]]
